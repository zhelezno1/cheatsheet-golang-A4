* Golang CheatSheet                                               :Languages:
:PROPERTIES:
:type:     language
:export_file_name: cheatsheet-golang-A4.pdf
:END:

#+BEGIN_HTML
<a href="https://github.com/dennyzhang/cheatsheet-golang-A4"><img align="right" width="200" height="183" src="https://www.dennyzhang.com/wp-content/uploads/denny/watermark/github.png" /></a>

<div id="the whole thing" style="overflow: hidden;">
<div style="float: left; padding: 5px"> <a href="https://www.linkedin.com/in/dennyzhang001"><img src="https://www.dennyzhang.com/wp-content/uploads/sns/linkedin.png" alt="linkedin" /></a></div>
<div style="float: left; padding: 5px"><a href="https://github.com/dennyzhang"><img src="https://www.dennyzhang.com/wp-content/uploads/sns/github.png" alt="github" /></a></div>
<div style="float: left; padding: 5px"><a href="https://www.dennyzhang.com/slack" target="_blank" rel="nofollow"><img src="https://www.dennyzhang.com/wp-content/uploads/sns/slack.png" alt="slack"/></a></div>
</div>

<br/><br/>
<a href="http://makeapullrequest.com" target="_blank" rel="nofollow"><img src="https://img.shields.io/badge/PRs-welcome-brightgreen.svg" alt="PRs Welcome"/></a>
#+END_HTML

- PDF Link: [[https://github.com/dennyzhang/cheatsheet-golang-A4/blob/master/cheatsheet-golang-A4.pdf][cheatsheet-golang-A4.pdf]], Category: [[https://cheatsheet.dennyzhang.com/category/languages/][languages]]
- Blog URL: https://cheatsheet.dennyzhang.com/cheatsheet-golang-A4
- Related posts: [[https://cheatsheet.dennyzhang.com/cheatsheet-ruby-A4][Ruby CheatSheet]], [[https://cheatsheet.dennyzhang.com/cheatsheet-python-A4][Python CheatSheet]], [[https://github.com/topics/denny-cheatsheets][#denny-cheatsheets]]

File me [[https://github.com/dennyzhang/cheatsheet-golang-A4/issues][Issues]] or star [[https://github.com/dennyzhang/cheatsheet-golang-A4][this repo]].
** Golang Conversion
| Name                           | Comment                                                         |
|--------------------------------+-----------------------------------------------------------------|
| Convert string to int          | i, _ := strconv.ParseInt("12345", 10, 64)                       |
| Convert string to int          | i, err := strconv.Atoi("-42")                                   |
| Convert string to list         | L := strings.Split("hi,golang", "")                             |
| Convert string to []byte       | =[]byte("abcXX")=                                               |
| Convert string to byte         | =byte(str1[])=                                                  |
| Convert byte to string         | =string(byte('a'))==                                            |
| Convert string to float32      | f, _ := strconv.ParseFloat("3.1415", 32)                        |
| Convert int to float32         | 0.5*float32(age)+7>= float32(age2)                              |
| Convert int to string          | s := strconv.Itoa(-42). Notice: not =string(-42)=               |
| Convert rune to string         | =string(rune1)=                                                 |
| Convert string list to string  | =strings.Join(list, ", ")=                                      |
| Convert int list to string     | =fmt.Sprintf("%s", l)=                                          |
| Convert list to byte           | byteI := byte(65)                                               |
| Convert byte to int            | =int(byte('a'))=                                                |
| Convert byte to string         | =string(byte('a'))=                                             |
| Convert bytes to string        | =string([]byte("abcXX"))=                                       |
| Convert int32 to int32 Pointer | =func int32Ptr(i int32) *int32 { return &i }=                   |
| Convert string[] to string     | =strings.Join([]string{"a", "b"}, ",")=                         |
| Format string                  | =fmt.Sprintf("%.3f", float64(v)/1000)=                          |
| Format string                  | =fmt.Sprintf("At %v, %s", e.When, e.What)=                      |
| Format string                  | =fmt.Printf("int: %d, float: %f, bool: %t\n", 123, 78.9, true)= |

** Deep Dive Into Golang
- Go's original target was networked system infrastructure, what we now call cloud software
| Name                                              | Comment                                                                                        |
|---------------------------------------------------+------------------------------------------------------------------------------------------------|
| Golang goroutine                                  |                                                                                                |
| [[https://medium.com/a-journey-with-go/go-how-does-defer-statement-work-1a9492689b6e][How Golang implement =defer=]]                      | Execute a piece of code before a function returns with FILO mechanism                          |
| How Golang implement timer                        |                                                                                                |
| Golang for vs loop                                |                                                                                                |
| Garbage Colection                                 |                                                                                                |
| Golang CSP vs Erlang Actor Model                  | Each actor model, which actor has its own queue                                                |
|---------------------------------------------------+------------------------------------------------------------------------------------------------|
| How Golang channel feature is implement?          | [[https://www.youtube.com/watch?v=KBZlN0izeiY][YouTube: GopherCon 2017: Understanding Channels]], [[https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/][Link: Golang Channel]]                          |
| Golang return a tuple                             | =func dfs(root *TreeNode, max *float64) (sum int, cnt int)=, [[https://code.dennyzhang.com/maximum-average-subtree][LeetCode: Maximum Average Subtree]] |
| Use strings.Builder, instead of string            | [[https://code.dennyzhang.com/unique-email-addresses][LeetCode: Unique Email Addresses]]                                                               |
| Variable Conversion                               | =float64(x_int/y_int)= != =float64(x_int)/float64(y_int)=, [[https://code.dennyzhang.com/maximum-average-subtree][LeetCode: Maximum Average Subtree]]   |
| For a list of objects, pass by value or reference | =f(l []*TreeNode)= vs =f(l *[]*TreeNode)=, [[https://code.dennyzhang.com/lowest-common-ancestor-of-a-binary-tree][LeetCode: Lowest Common Ancestor of a Binary Tree]]   |
** Golang Quality Improvement Tools
| Name              | Comment                                                                      |
|-------------------+------------------------------------------------------------------------------|
| [[https://github.com/securego/gosec][gosec]]             | Golang security checker, =gosec ./...=                                       |
| [[https://github.com/golangci/golangci-lint/tree/master/cmd/golangci-lint][golangci-lint]]     | lint check, =golint=                                                         |
| [[https://github.com/kisielk/errcheck][errcheck]]          | errcheck checks that you checked errors, =errcheck ./...=                    |
| [[https://github.com/go-delve/delve][delve]]             | Delve is a debugger for the Go programming language.                         |
| [[https://github.com/onsi/ginkgo/tree/master/ginkgo][ginkgo]]            | BDD Testing Framework for Go                                                 |
| [[https://github.com/golang/mock][mock]]              | GoMock is a mocking framework for Golang                                     |
| [[https://godoc.org/sigs.k8s.io/controller-runtime/pkg/envtest][envtest]]           | provides libraries for integration testing by starting a local control plane |
| [[https://github.com/jstemmer/go-junit-report/tree/master][go-junit-report]]   | Convert go test output to junit xml                                          |
| [[https://github.com/t-yuki/gocover-cobertura/tree/master][gocover-cobertura]] | go tool cover to XML (Cobertura) export tool                                 |
| [[https://github.com/wadey/gocovmerge/tree/master][gocovmerge]]        | Merge coverprofile results from multiple go cover runs                       |
** Golang Dependencies
| Name                                       | Comment                                                                          |
|--------------------------------------------+----------------------------------------------------------------------------------|
| [[https://godoc.org/golang.org/x/tools/cmd/goimports][goimports]]                                  | updates your Go import lines, adding missing ones and removing unreferenced ones |
| [[https://github.com/golang/dep/tree/master/cmd/dep][dep]]                                        | Go deps, now recommend =go modules=                                              |
| [[https://golang.github.io/dep/docs/installation.html][Install go dep]]                             | =go get -u github.com/golang/dep/cmd/dep=                                        |
| Go modules                                 | export GO111MODULE=on, =go mod download=                                         |
| Initialize new module in current directory | =go mod init XXX=                                                                |
| Download modules to local cache            | =go mod download=                                                                |
| Add missing and remove unused modules      | =go mod tidy=                                                                    |
| Make vendored copy of dependencies         | =go mod vendor=                                                                  |
| Reference                                  | [[https://blog.golang.org/using-go-modules][Link: Using Go Modules]]                                                           |

** Golang Errors
| Name                          | Comment                            |
|-------------------------------+------------------------------------|
| [[https://flaviocopes.com/golang-does-not-support-indexing/][... does not support indexing]] | =*variable[0]= -> =(*variable)[0]= |

** Golang Common
| Name                          | Comment                                         |
|-------------------------------+-------------------------------------------------|
| [[https://www.grailbox.com/2019/02/installing-go-1-12-on-macos-high-sierra/][Upgrade golang to 1.12 in mac]] | =brew upgrade go=, =go version=                 |
| Reference                     | [[https://golang.org/ref/spec][Link: The Go Programming Language Specification]] |

** Golang Code Structure & Common Algorithms
| Name                                | Comment                                          |
|-------------------------------------+--------------------------------------------------|
| Online Go Playgroud                 | https://play.golang.org/                         |
| One line if statement               | if a >= 1 { fmt.Print("yes") }                   |
| Declare variables with initializers | var ischecked, v, str  = false, 2, "yes!"        |
| goroutine                           | Define functions to run as distince subprocesses |
| switch                              | [[https://github.com/dennyzhang/cheatsheet-golang-A4/blob/master/code/example-switch.go][code/example-switch.go]]                           |
| queue                               | [[https://code.dennyzhang.com/number-of-recent-calls][LeetCode: Number of Recent Calls]]                 |
| bfs                                 | [[https://github.com/dennyzhang/cheatsheet-golang-A4/blob/master/code/tree-bfs.go][code/tree-bfs.go]]                                 |
| trie tree                           | [[https://github.com/dennyzhang/cheatsheet-golang-A4/blob/master/code/tree-trie.go][code/tree-trie.go]]                                |
#+BEGIN_HTML
<a href="https://cheatsheet.dennyzhang.com"><img align="right" width="185" height="37" src="https://raw.githubusercontent.com/dennyzhang/cheatsheet.dennyzhang.com/master/images/cheatsheet_dns.png"></a>
#+END_HTML
** Syntax Sugar: From Python To Golang
| Name           | Python                                   | Golang                                           |
|----------------+------------------------------------------+--------------------------------------------------|
| sum slice      | =sum([1, 2, 3])=                         | sum := 0; for i := range nums { sum += nums[i] } |
| Get last item  | =nums[-1]=                               | nums[len(nums)-1]                                |
| For            | =for i in range(10):=                    | for i := 0; i < 10; i++                          |
| Loop list      | =for num in [1, 2]=                      | for num := range[]int{1, 2} { fmt.Print(num) }   |
| Loop string    | =for ch in str:=                         | for _, ch := range str { fmt.Print(ch) }         |
| Iterator       | =for num in nums:=                       | for _, num := range nums {fmt.Print(num)}        |
| While          | =while isOK:=                            | =for isOK=                                       |
| Check ch range | =ord(ch) in range(ord('a'), ord('z')+1)= | ch >='a' && ch <='z'                             |
| Get min        | =min(2, 6, 5)=                           |                                                  |
| Check is nil   | =root is None=                           | root == nil                                      |
| Reverse list   | =nums[::-1]=                             | Need to create your own function. Weird!         |
** Surprises In Golang
| Name                             | Comment                 |
|----------------------------------+-------------------------|
| [[https://github.com/golang/go/issues/448][Modulus returns negative numbers]] | In golang, -3 % 2 == -1 |
** Golang Array/List/Slice
| Name                                   | Comment                                        |
|----------------------------------------+------------------------------------------------|
| Make a array                           | var a [2]string; a[0]="hello"; a[1]="world"    |
| Create array with given values         | l := [6]int{2, 3, 7, 5, 11, 13}                |
| Create array with given values         | l := []string{"a", "c", "b", "d"}              |
| Create dynamically-sized arrays        | a := make([]int, 5)                            |
| Create dynamically-sized arrays        | a := make([]int, 1, 5) // 5 is capacity        |
| Sort string array                      | =sort.Strings(l); fmt.Print(l)=                |
| Sort int array                         | =sort.Ints(l)= //in-place change               |
| Golang sort one array by another array | [[https://code.dennyzhang.com/largest-values-from-labels][LeetCode: Largest Values From Labels]]           |
| [[https://stackoverflow.com/questions/37695209/golang-sort-slice-ascending-or-descending/40932847][Sort in descending order]]               | =sort.Sort(sort.Reverse(sort.IntSlice(keys)))= |
| Append item                            | l = append(l, "e")                             |
| Append items                           | l = append(l, "e", "b", "c")                   |
| Append item to head/prepend            | =l = append([]string{"a"}, l...)=              |
| Remove last item                       | =l = l[:len(l)-1]=                             |
| Remove item by index                   | =l = append(l[0:1], l[2:]...)=                 |
| Slices of a array                      | =var l2 = l[1:3]= // Notice: it's a reference  |
| Copy a list                            | b := make([]int, len(a)); copy(b, a)           |
| Join two lists                         | =l1 = append(l1, l2...)=                       |
| Use pointer of array list              | [[https://github.com/dennyzhang/cheatsheet-golang-A4/blob/master/code/pointer-array.go][code/pointer-array.go]]                          |
** Golang String
| Name                         | Comment                                                         |
|------------------------------+-----------------------------------------------------------------|
| Format string                | =fmt.Sprintf("At %v, %s", e.When, e.What)=                      |
| Format string                | =fmt.Printf("int: %d, float: %f, bool: %t\n", 123, 78.9, true)= |
| [[https://stackoverflow.com/questions/25637440/how-to-pad-a-number-with-zeros-when-printing][Padding zero]]                 | =fmt.Printf("%02d:%02d", 2, 10)=                                |
| Split string                 | =var L = strings.Split("hi,golang", ",")=                       |
| Replace string               | =var str2 = strings.Replace("hi,all", ",", ";", -1)=            |
| Replace string               | =strings.Replace("aaaa", "a", "b", 2)= //bbaa                   |
| Split string by separator    | =strings.Split(path, " ")=                                      |
| Count characters             | =strings.Count("test", "t")=                                    |
| Substring                    | =strings.Index("test", "e")=                                    |
| Join string                  | =strings.Join([]string{"a","b"}, "-")=                          |
| Repeat string                | =strings.Repeat("a", 2)= // aa                                  |
| Lower string                 | =strings.ToLower("TEST")=                                       |
| Trim whitespace in two sides | =strings.TrimSpace("\t Hello world!\n ")=                       |
| Trim trailing whitespace     | =strings.TrimRight("\t Hello world!\n ", "\n ")=                |
| Concact string               | =fmt.Sprintf("%s%s", str1, str2)=                               |
| Reference                    | [[https://golang.org/pkg/strings/][Link: package strings]]                                           |
** Golang Integer/Float
| Name                  | Comment                          |
|-----------------------+----------------------------------|
| Int max               | MaxInt32 = 1<<31 - 1 [[https://golang.org/pkg/math/][golang math]] |
| Int min               | MinInt32 = -1 << 31 [[https://golang.org/pkg/math/][golang math]]  |
| Pass int as reference | [[https://code.dennyzhang.com/binary-tree-longest-consecutive-sequence][sample code]]                      |
** Golang Env
| Name      | Comment                                                       |
|-----------+---------------------------------------------------------------|
| GOPATH    | It is called as the workspace directory for Go programs       |
| [[https://www.programming-books.io/essential/go/gopath-goroot-gobin-d6da4b8481f94757bae43be1fdfa9e73][GOROOT]]    | The location of your Go installation. No need to set any more |
| =go env=  | Show a full list of environment variables                     |
| Reference | [[https://www.programming-books.io/essential/go/gopath-goroot-gobin-d6da4b8481f94757bae43be1fdfa9e73][Link: GOPATH, GOROOT, GOBIN]]                                   |
** Golang Package management
| Name               | Comment                             |
|--------------------+-------------------------------------|
| go mod             | [[https://github.com/golang/go/wiki/Modules][Link: go modules]]                    |
| go get fix         | =GO111MODULE=off go get -fix ./...= |
| go mod replace url | go mod edit -replace...             |
** Golang Ascii
| Name                | Comment                                          |
|---------------------+--------------------------------------------------|
| get character ascii | =byte('0')=                                      |
| ascii offset        | =fmt.Println(string('B' + byte('a')-byte('A')))= |
** Golang Dict/Hashmap/Map
| Name                      | Comment                                                  |
|---------------------------+----------------------------------------------------------|
| Create dict               | =map[string]int{"a": 1, "b": 2}=                         |
| Create dict               | =make(map[string]int)=                                   |
| Check existence           | _, ok := m[k]                                            |
| Delete key                | =delete(m, "k1")=                                        |
| Create a map of lists     | m := make(map[string][]string)                           |
| Get keys of a map         | Loop the dictionary and append the key to a list         |
| Use (x, y) as hashmap key | m[[2]int{2, 2}] = true, [[https://github.com/dennyzhang/cheatsheet-golang-A4/blob/master/code/example-hashmap-arraykey.go][code/example-hashmap-arraykey.go]] |

** Golang Networking
| Name        | Comment              |
|-------------+----------------------|
| golang http | [[https://github.com/dennyzhang/cheatsheet-golang-A4/blob/master/code/example-http.go][code/example-http.go]] |

** Golang Goroutines
| Name            | Comment                   |
|-----------------+---------------------------|
| Basic goroutine | [[https://github.com/dennyzhang/cheatsheet-golang-A4/blob/master/code/example-goroutine.go][code/example-goroutine.go]] |
#+BEGIN_HTML
<a href="https://cheatsheet.dennyzhang.com"><img align="right" width="185" height="37" src="https://raw.githubusercontent.com/dennyzhang/cheatsheet.dennyzhang.com/master/images/cheatsheet_dns.png"></a>
#+END_HTML
** Golang Inteface
| Name                                                       | Comment                       |
|------------------------------------------------------------+-------------------------------|
| Hash map with both key and value dynamic                   | =map[interface{}]interface{}= |
| Define and use interface                                   | [[https://github.com/dennyzhang/cheatsheet-golang-A4/blob/master/code/example-interface.go][code/example-interface.go]]     |
| Convert map[interface {}]interface {} to map[string]string | [[https://github.com/dennyzhang/cheatsheet-golang-A4/blob/master/code/interface-conversion.go][code/interface-conversion.go]]  |
** Golang Files & Folders
| Name        | Comment                    |
|-------------+----------------------------|
| Read files  | [[https://github.com/dennyzhang/cheatsheet-golang-A4/blob/master/code/example-read-file.go][code/example-read-file.go]] |
| Write files | [[https://github.com/dennyzhang/cheatsheet-golang-A4/blob/master/code/example-write-file.go][code/example-write-file.go]] |
** Golang Math
| Name      | Comment                                     |
|-----------+---------------------------------------------|
| pow(2, 3) | =int(math.Pow(2, 3))= // Default is float64 |
| sqrt      | =math.Sqrt(100)=                            |
| [[https://gobyexample.com/random-numbers][Get rand]]  | =rand.Intn(100)=, =rand.Float64()=          |
** Golang Bit Operator & Math
| Name        | Comment                                     |
|-------------+---------------------------------------------|
| Shift left  | =fmt.Print(1 << 10)= // 1024                |
| Shift right | =fmt.Print(1024 >> 3)= // 128               |
** Golang BBD Testing
| Name                  | Summary                                                                   |
|-----------------------+---------------------------------------------------------------------------|
| ginkgo                | BDD Testing Framework for Go http://onsi.github.io/ginkgo/                |
| [[https://www.howtoinstall.co/en/ubuntu/xenial/golang-ginkgo-dev][Ubuntu install ginkgo]] | =apt-get install golang-ginkgo-dev=                                       |
| [[http://onsi.github.io/gomega][gomega]]                | Ginkgo's Preferred Matcher Library                                        |
| Add tags to tests     | =// +build availability=, =go test -v --tags=availability ./test/e2e/...= |
** Golang Misc
| Name                       | Comment                                                   |
|----------------------------+-----------------------------------------------------------|
| [[https://gobyexample.com/timeouts][Golang sleep]]               | =time.Sleep(4* time.Second)=                              |
| [[https://golang.org/pkg/log/][Golang logging]]             | =import "log"=, =log.Info=, =log.Print=, =log.Error(err)= |
| [[https://stackoverflow.com/questions/25927660/how-to-get-the-current-function-name][Golang print function name]] | =runtime.Callers=                                         |
** More Resources
https://play.golang.org/

https://tour.golang.org/list

https://golang.org/doc/

https://github.com/a8m/go-lang-cheat-sheet

 License: Code is licensed under [[https://www.dennyzhang.com/wp-content/mit_license.txt][MIT License]].
#+BEGIN_HTML
 <a href="https://cheatsheet.dennyzhang.com"><img align="right" width="201" height="268" src="https://raw.githubusercontent.com/USDevOps/mywechat-slack-group/master/images/denny_201706.png"></a>
 <a href="https://cheatsheet.dennyzhang.com"><img align="right" src="https://raw.githubusercontent.com/dennyzhang/cheatsheet.dennyzhang.com/master/images/cheatsheet_dns.png"></a>

 <a href="https://www.linkedin.com/in/dennyzhang001"><img align="bottom" src="https://www.dennyzhang.com/wp-content/uploads/sns/linkedin.png" alt="linkedin" /></a>
 <a href="https://github.com/dennyzhang"><img align="bottom"src="https://www.dennyzhang.com/wp-content/uploads/sns/github.png" alt="github" /></a>
 <a href="https://www.dennyzhang.com/slack" target="_blank" rel="nofollow"><img align="bottom" src="https://www.dennyzhang.com/wp-content/uploads/sns/slack.png" alt="slack"/></a>
#+END_HTML
* org-mode configuration                                           :noexport:
#+STARTUP: overview customtime noalign logdone showall
#+DESCRIPTION:
#+KEYWORDS:
#+LATEX_HEADER: \usepackage[margin=0.6in]{geometry}
#+LaTeX_CLASS_OPTIONS: [8pt]
#+LATEX_HEADER: \usepackage[english]{babel}
#+LATEX_HEADER: \usepackage{lastpage}
#+LATEX_HEADER: \usepackage{fancyhdr}
#+LATEX_HEADER: \pagestyle{fancy}
#+LATEX_HEADER: \fancyhf{}
#+LATEX_HEADER: \rhead{Updated: \today}
#+LATEX_HEADER: \rfoot{\thepage\ of \pageref{LastPage}}
#+LATEX_HEADER: \lfoot{\href{https://github.com/dennyzhang/cheatsheet-golang-A4}{GitHub: https://github.com/dennyzhang/cheatsheet-golang-A4}}
#+LATEX_HEADER: \lhead{\href{https://cheatsheet.dennyzhang.com/cheatsheet-golang-A4}{Blog URL: https://cheatsheet.dennyzhang.com/cheatsheet-golang-A4}}
#+AUTHOR: Denny Zhang
#+EMAIL:  denny@dennyzhang.com
#+TAGS: noexport(n)
#+PRIORITIES: A D C
#+OPTIONS:   H:3 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:nil skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+EXPORT_EXCLUDE_TAGS: exclude noexport
#+SEQ_TODO: TODO HALF ASSIGN | DONE BYPASS DELEGATE CANCELED DEFERRED
#+LINK_UP:
#+LINK_HOME:
* #  --8<-------------------------- separator ------------------------>8-- :noexport:
* DONE Code snippets                                               :noexport:
  CLOSED: [2018-11-17 Sat 12:12]
- Create 2D arrays
#+BEGIN_SRC go
// static
board := [][]string{
         []string{"_", "_", "_"},
         []string{"_", "_", "_"},
         []string{"_", "_", "_"},
}

// dynamic
a := make([][]uint8, dy)
for i := range a {
    a[i] = make([]uint8, dx)
}
#+END_SRC

- Logging
#+BEGIN_SRC go
import "github.com/op/go-logging"
log := logging.MustGetLogger("my-app")
log.Info("Some info...")
log.Warning("Some warning...")
log.Error("Some error!")
log.Critical("Some critical!")
#+END_SRC

- struct
#+BEGIN_SRC go
type Point struct {
  X, Y int
}

var (
  v1 = Point{10, 8}
  v2 = Point{X: 1}  // Y would be 0
  v3 = Point{}      // Both X and Y is 0
  p  = &Point{10, 8} // reference: type *Point
)

func main() {
  fmt.Println(p, v1, v2, v3)
}
#+END_SRC

- Print Map

#+BEGIN_SRC go
import "encoding/json"

b, err := json.MarshalIndent(x, "", "  ")
fmt.Println(string(b))
#+END_SRC

#+BEGIN_SRC go
for key := range record {
   fmt.Printf("key: %s, value: %s\n", key, record[key])
}
#+END_SRC

- Print TreeNode
#+BEGIN_SRC go
func printTreeNodePreOrder(root *TreeNode) {
    if root == nil { return }
    fmt.Println(root.Val)
    if root.Left != nil { printTreeNodePreOrder(root.Left) }
    if root.Right != nil { printTreeNodePreOrder(root.Right) }
}
#+END_SRC

- Goroutines & Channels
#+BEGIN_SRC go
// Goroutines
go func() {
  // do something
}
#+END_SRC

#+BEGIN_SRC go
// Channels
c := make(chan T [, capacity ])
c <- t // blocks on unbuffered channels until another routine receives the value

d := <-c // blocks on unbuffered channels until another routine sends the value

close(c)
#+END_SRC
* DONE [#A] Go by Example: Sorting by Functions                    :noexport:
  CLOSED: [2018-04-17 Tue 11:06]
https://stackoverflow.com/questions/28999735/what-is-the-shortest-way-to-simply-sort-an-array-of-structs-by-arbitrary-field
https://gobyexample.com/sorting-by-functions

sort.Slice(planets, func(i, j int) bool {
  return planets[i].Axis < planets[j].Axis
})
* DONE golang struct                                               :noexport:
  CLOSED: [2018-04-16 Mon 23:10]
https://tour.golang.org/moretypes/2
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	fmt.Println(Vertex{1, 2})
}
* DONE golang log package                                          :noexport:
  CLOSED: [2018-07-03 Tue 11:23]
* DONE go get -t to retrieve the packages referenced in your code  :noexport:
  CLOSED: [2018-07-04 Wed 10:02]
http://onsi.github.io/gomega/
#+BEGIN_EXAMPLE
$ cd /path/to/my/app
$ go get -t ./...
#+END_EXAMPLE
* DONE [#A] golang workspace                             :IMPORTANT:noexport:
  CLOSED: [2018-07-05 Thu 14:40]
https://golang.org/doc/code.html#Workspaces
* DONE go get github package with specific version: go dep         :noexport:
  CLOSED: [2018-07-11 Wed 09:25]
https://gist.github.com/subfuzion/12342599e26f5094e4e2d08e9d4ad50d

dep init
dep ensure
dep ensure --add github.com/gorilla/websocket@1.2.0

https://stackoverflow.com/questions/24855081/how-do-i-import-a-specific-version-of-a-package-using-go-get
https://github.com/golang/go/issues/21933
https://github.com/golang/dep
https://github.com/golang/go/wiki/PackagePublishing
* DONE golang invalid character '\n' in string literal             :noexport:
  CLOSED: [2018-08-01 Wed 17:26]
https://stackoverflow.com/questions/38977555/error-embedding-n-into-a-string-literal
#+BEGIN_SRC go
separator := `\n    `
#+END_SRC

or
#+BEGIN_SRC go
separator := "\\n    "
#+END_SRC
* Golang                                                    :noexport:Coding:
:PROPERTIES:
:type:   Language
:END:

- Packages
| Name     | Comment                      |
|----------+------------------------------|
| strconv  | 字符串和基本数据类型间的转换 |
| fmt      | 格式化的IO输出               |
| io       | 原始的IO操作                 |
| bufio    | 实现缓冲的IO操作             |
| sort     | 对数组和集合的排序           |
| os       | 操作系统接口包               |
| sync     | 同步包                       |
| flag     | 命令行解析                   |
| templete | 数据模板                     |
| http     | HTTP服务实现包               |
| reflect  | 反射包                       |
| exec     | 执行外部命令包               |
** #  --8<-------------------------- separator ------------------------>8-- :noexport:
** DONE golang json
  CLOSED: [2018-04-07 Sat 19:10]
Marshalling to JSON
#+BEGIN_SRC go
import "encoding/json"
data := []int{1,2,3,4,5}
json.Marshal(data)
Marshalling structs
type Object struct {
    ExportedField string `json:"exported_field"`
}
json.Marshal(&Object{
    ExportedField: "some info",
})
// {"exported_field":"some info"}
#+END_SRC
** DONE golang one line if
  CLOSED: [2018-04-08 Sun 12:29]
var c int
if c = b; a > b {
    c = a
}
** Install Golang
*** HALF Ubuntu install Go 1.6 by source code
https://www.digitalocean.com/community/tutorials/how-to-install-go-1-6-on-ubuntu-14-04

cd /tmp/
curl -O https://storage.googleapis.com/golang/go1.6.linux-amd64.tar.gz
tar -xvf go1.6.linux-amd64.tar.gz
mv go /usr/local

export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin

go version
*** install go
sudo easy_install mercurial

hg clone -u release https://go.googlecode.com/hg/ go

cd go/src

./all.bash
**** DONE 安装the parser generator Bison: sudo apt-get install bison :noexport:
 CLOSED: [2011-09-29 Thu 10:53]
Bison is a general-purpose parser generator that converts an annotated context-free grammar into an LALR or GLR parser for that grammar. Once you are proficient with Bison, you can use it to develop a wide range of language parsers, from those used in simple desk calculators to complex programming languages.

http://www.techsww.com/tutorials/operating_systems/linux/tools/installing_bison_gnu_parser_generator_ubuntu_linux.php\\
::Techs Worldwide:: Installing Bison (GNU Parser Generator) on Ubuntu Linux
***** ./all.bash Cannot find 'bison' on search path.
denny@ubuntu:/tmp/google-go/go/src$ ./all.bash
Cannot find 'bison' on search path.
See http://golang.org/doc/install.html#ctools
*** TODO Ubuntu 16.04 install google golang
https://www.digitalocean.com/community/tutorials/how-to-install-go-1-6-on-ubuntu-16-04
https://medium.com/@patdhlk/how-to-install-go-1-8-on-ubuntu-16-04-710967aa53c9
** Golang regexp
*** DONE [#B] regexp允许大小写
  CLOSED: [2013-02-12 Tue 01:16]
http://www.datamation.com/open-source/ubuntu-what-theyre-doing-right-and-wrong-1.html
	title := regexp.MustCompile(`<title>([^<]*)</title>`).FindAllStringSubmatch(content, -1)

<TITLE>Ubuntu: What They're Doing Right and Wrong - Datamation</title>

/home/denny/go/src/pkg/regexp/exec_test.go
*** DONE Regex to match any character including new lines ?(m)
  CLOSED: [2013-02-12 Tue 01:17]
http://stackoverflow.com/questions/8303488/regex-to-match-any-character-including-new-lines
** basic use
#+BEGIN_EXAMPLE
Go is an expressive, concurrent, garbage-collected programming language.

Go所需的内存和执行占用空间要比C和C++高得多
在Go中可以实现原始且直接控制内存访问.

Go语言最初定位于网络服务器`存储系统和数据库的程序设计,同时在语言中包含并发构造体,以方便的帮助开发者创建并行任务.

现有的语言都没有针对多核心处理器进行优化,为了解决此类编程问题,Google工程师们开发了Go语言.
#+END_EXAMPLE
*** [#A] go的个人感悟                                              :noexport:
- 数组的切片功能
- 指针和引用依然存在
- 相较于继承,Go鼓励使用组合和委派
- 多返回值: 函数返回多维变量
- 每行代码没有结束符
- channel的消息队列
*** The Go compilers support three instruction sets.               :noexport:
#+begin_example
amd64 (a.k.a. x86-64); 6g,6l,6c,6a
 The most mature implementation. The compiler has an effective optimizer (registerizer) and generates good code (although gccgo can do noticeably better sometimes).
386 (a.k.a. x86 or x86-32); 8g,8l,8c,8a
 Comparable to the amd64 port.
arm (a.k.a. ARM); 5g,5l,5c,5a
 Incomplete. It only supports Linux binaries, the optimizer is incomplete, and floating point uses the VFP unit. However, all tests pass. Work on the optimizer is continuing. Tested against a Nexus One.
#+end_example
*** Environment variables                                          :noexport:
#+begin_example


 http://golang.org/doc/install.html\\
The Go compilation environment can be customized by environment variables. None are required by the build, but you may wish to set them to override the defaults.

$GOROOT
 The root of the Go tree, often $HOME/go. This defaults to the parent of the directory where all.bash is run. If you choose not to set $GOROOT, you must run gomake instead of make or gmake when developing Go programs using the conventional makefiles.
$GOROOT_FINAL
 The value assumed by installed binaries and scripts when $GOROOT is not set. It defaults to the value used for $GOROOT. If you want to build the Go tree in one location but move it elsewhere after the build, set $GOROOT_FINAL to the eventual location.
$GOOS and $GOARCH
 The name of the target operating system and compilation architecture. These default to the values of $GOHOSTOS and $GOHOSTARCH respectively (described below).

 Choices for $GOOS are linux, freebsd, darwin (Mac OS X 10.5 or 10.6), and windows (Windows, an incomplete port). Choices for $GOARCH are amd64 (64-bit x86, the most mature port), 386 (32-bit x86), and arm (32-bit ARM, an incomplete port). The valid combinations of $GOOS and $GOARCH are:
 	$GOOS 	$GOARCH
 	darwin 	386
 	darwin 	amd64
 	freebsd 	386
 	freebsd 	amd64
 	linux 	386
 	linux 	amd64
 	linux 	arm 	incomplete
 	windows 	386 	incomplete
$GOHOSTOS and $GOHOSTARCH
 The name of the host operating system and compilation architecture. These default to the local system's operating system and architecture.

 Valid choices are the same as for $GOOS and $GOARCH, listed above. The specified values must be compatible with the local system. For example, you should not set $GOHOSTARCH to arm on an x86 system.
$GOBIN
 The location where binaries will be installed. The default is $GOROOT/bin. After installing, you will want to arrange to add this directory to your $PATH, so you can use the tools.
$GOARM (arm, default=6)
 The ARM architecture version the run-time libraries should target. ARMv6 cores have more efficient synchronization primitives. Setting $GOARM to 5 will compile the run-time libraries using just SWP instructions that work on older architectures as well. Running v6 code on an older core will cause an illegal instruction trap.

Note that $GOARCH and $GOOS identify the target environment, not the environment you are running on. In effect, you are always cross-compiling. By architecture, we mean the kind of binaries that the target environment can run: an x86-64 system running a 32-bit-only operating system must set GOARCH to 386, not amd64.

If you choose to override the defaults, set these variables in your shell profile ($HOME/.bashrc, $HOME/.profile, or equivalent). The settings might look something like this:

export GOROOT=$HOME/go
export GOARCH=386
export GOOS=linux
#+end_example
** useful link
 http://www.oschina.net/question/12_7902\\
 编程语言 Google Go 的初级读本 - 讨论区 - 开源中国社区
 http://golang.org/#package%20main%0A%0Aimport%20%22fmt%22%0A%0Afunc%20main%28%29%20{%0A%09fmt.Println%28%22Hello%2C%20%E4%B8%96%E7%95%8C%22%29%0A}%0A\\
 The Go Programming Language
** TODO [#A] Channel提供一个FIFO通信队列
channel的阻塞行为并非永远是最佳的.该语言提供了两种对其进行定制的方式:

 1. 程序员可以指定缓冲大小--想缓冲的channel发送消息不会阻塞,除非缓冲已满,同样从缓冲的channel读取也不会阻塞,除非缓 冲是空的.
 2. 该语言同时还提供了不会被阻塞的发送和接收的能力,而操作成功是仍然要报告.
*** 通过两个channel实现, fabonaci计算                               :Sample:
#+begin_src go
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Compute Fibonacci numbers with two goroutines
// that pass integers back and forth. No actual
// concurrency, just threads and synchronization
// and foreign code on multiple pthreads.

package main

import (
	big "gmp"
	"runtime"
)

func fibber(c chan *big.Int, out chan string, n int64) {
	// Keep the fibbers in dedicated operating system
	// threads, so that this program tests coordination
	// between pthreads and not just goroutines.
	runtime.LockOSThread()

	i := big.NewInt(n)
	if n == 0 {
		c <- i
	}
	for {
		j := <-c
		out <- j.String()
		i.Add(i, j)
		c <- i
	}
}

func main() {
	c := make(chan *big.Int)
	out := make(chan string)
	go fibber(c, out, 0)
	go fibber(c, out, 1)
	for i := 0; i < 200; i++ {
		println(<-out)
	}
}
#+end_src
** TODO 没有shell的交互式运行
** TODO =与:=的区别是什么
** DONE golang write file: ioutil.WriteFile("out.html", []byte(content_str), 0644)
   CLOSED: [2013-02-06 Wed 18:12]
** concat two arrays or slices
https://groups.google.com/forum/?fromgroups=#!topic/golang-nuts/mRUD0KffSG4
#+begin_example
Assuming slices of ints, you can do (not really tested):

func concat(old1, old2 []int) []int {
   newslice := make([]int, len(old1) + len(old2))
   copy(newslice, old1)
   copy(newslice[len(old1):], old2)
   return newslice
}

A fun little exercise might be to write

func concat(slices ...[]int) []int

That is, a function to concatenate efficiently an arbitrary number of slices, as opposed to just two.
#+end_example
** 注意if...else...缩进
#+begin_src go
		if object == "content" {
			content = action(content, from_str, end_str)
		} else {
			title = action(title, from_str, end_str)
		}
#+end_src
** DONE golang中anonymous function避免了不少超短函数的问题
  CLOSED: [2013-02-08 Fri 10:47]
#+begin_src go
var generator = map[string] Stringy {
	"http://haowenz.com/a/bl/": Generator_haowenzcom_1,

	// RSS feed
	"http://www.36kr.com/feed": func(url string) []Task { return generator_rss(url,
			"<link>(http://www.36kr.com/p/[0-9]*.html)</link>") },
}

#+end_src
** DONE golang与C/C++不同, package不同文件定义的include没有先后顺序的依赖问题
   CLOSED: [2013-02-08 Fri 10:48]
** DONE [#B] 使用golang后,深刻怀念erlang的lists:sort, lists:map之类的功能
  CLOSED: [2013-02-08 Fri 10:48]
#+begin_src go
func Generator_haowenzcom_1(url string) []Task {
	tasks := make([]Task, 0)
        _, content := webcrawler.Webcrawler(url)
        content = webcrawler.Filter_content(content,"当前位置", "首页")
        match_strings := regexp.MustCompile("#.*耽美微小说.*日期.*点击.*</span>").FindAllStringSubmatch(content, -1)
        for i := range match_strings {
		record_string := match_strings[i][0]
		//fmt.Print(record_string)
                url_match_record := regexp.MustCompile("# <a href=\"([^\"]*)\"").FindAllStringSubmatch(record_string, -1)
		// fmt.Print("\nurl:"+url_match_record[0][1]+"\n")
		tasks = append(tasks, Task{url_match_record[0][1]})

                // date_match_record := regexp.MustCompile("日期:</small>([0-9-: ]*)").FindAllStringSubmatch(record_string, -1)
		// fmt.Print("\ndate:"+date_match_record[0][1]+"\n")

                // count_match_record := regexp.MustCompile("</small>([0-9]*) </span>").FindAllStringSubmatch(record_string, -1)
		// fmt.Print("\ncount:"+count_match_record[0][1]+"\n")
        }

	//fmt.Print(tasks)

        return tasks
}
#+end_src
** DONE golang允许两个函数名相同,但大小写不一样的情况; 但不允许函数重载
  CLOSED: [2013-02-09 Sat 10:25]
#+begin_src go
package main

import (
	"fmt"
)
func test1() string {
	return "test1"
}

func Test1() string {
	return "Test1"
}
func main() {
	fmt.Printf(test1())
	fmt.Printf("\n")
	fmt.Printf(Test1())
	fmt.Printf("\n")
}
#+end_src
** # --8<-------------------------- separator ------------------------>8--
** DONE getopt
   CLOSED: [2013-02-12 Tue 13:30]
http://stackoverflow.com/questions/1714236/getopt-like-behavior-in-go

go run ./test.go -help -version --monkey business
#+begin_src go
package main
import ("fmt"; "os")
func main() {
	i := 0
	for _,arg := range os.Args {
		if arg == "-help" {
			fmt.Printf ("I need somebody\n")
		} else if arg == "-version" {
			fmt.Printf ("Version Zero\n")
		} else {
			fmt.Printf("arg %d: %s\n", i, os.Args[i])
		}
                i = i + 1
	}
}
#+end_src

#+begin_src go
func parse_opt(args []string) bool {
        // go run ./src/main.go --fetch_url "http://haowenz.com/a/bl/list_4_4.html" --shall_generator --dst_dir "webcrawler_raw_haowenz"
        // go run ./src/main.go --fetch_url "http://haowenz.com/a/bl/2013/2608.html" --dst_dir "webcrawler_raw_haowenz"
	count := len(args)
	for i := 0; i<count; i++ {
                switch args[i] {
                case "--dst_dir":
                        dst_dir = args[i+1]
                        i = i + 1
                case "--fetch_url":
                        fetch_url = args[i+1]
                        i = i + 1
                case "--shall_generator":
                        shall_generator = true
                default:
                        fmt.Printf("Error: Unknown option for " + args[i])
                }
	}
        return true
}
#+end_src
** DONE golang print current function and current line
  CLOSED: [2013-02-12 Tue 14:32]
  http://stackoverflow.com/questions/4947705/go-is-there-a-way-to-get-the-source-code-filename-and-line-number-in-go

/home/denny/go/src/pkg/runtime/extern.go
#+begin_src go
package main
import ("fmt"
	"runtime"
)
func test() bool {
	_, file, line, _ := runtime.Caller(3)
	fmt.Print(file)
	fmt.Print("\n")
	fmt.Print(line)
	fmt.Print("\n")

	return true
}

func main() {
	test()
}
#+end_src
** DONE golang http get set header
  CLOSED: [2013-02-13 Wed 17:17]
http://stackoverflow.com/questions/12864302/how-to-set-headers-in-http-get-request
#+begin_src go
	client := &http.Client{}
	req, err := http.NewRequest("GET", url, nil)
	req.Header.Set("Cookie", "q_c0=\"NDBiMDcyYzEyYTE0ZjA5N2U4NmE3NTRjNzNlN2FlYTh8aG45U1QwM0FBcldGYXNqNw==|1360513150|122c5023e9667a713c9d34f91b104309754323a0\"") // TODO
	errorHandler(err)
	resp, err := client.Do(req)
#+end_src
** DONE golang read file
   CLOSED: [2013-02-17 Sun 00:03]
http://stackoverflow.com/questions/5884154/golang-read-text-file-into-string-array-and-write
#+begin_src go
func test_url(url string) bool {
	tmp_file := "/tmp/test"
        bytes, err := ioutil.ReadFile(tmp_file)
        if err == nil {
		fmt.Print(string(bytes))
		fmt.Print("\n")
        }
        return true
}
#+end_src
** DONE [#A] [讨论] golang convert html entity to Unicode         :IMPORTANT:
  CLOSED: [2013-02-17 Sun 17:42]
#+begin_src go
package main
import ("fmt"
	"html/template"
	"strconv"
)

func main() {
	fmt.Print("\ncontent:\n")
	fmt.Print(template.HTMLEscapeString("\\u987e"))

	fmt.Print("\ncontent:\n")
	fmt.Print(template.HTMLEscapeString("\u987e"))
	fmt.Print("\nend\n")

        content := "\\u987e"
	i, _ := strconv.ParseUint(content[2:], 16, 0)
	fmt.Print(string(i))
	fmt.Print("\n")

	fmt.Print("\nend\n")
}
#+end_src
** DONE 简化golang的for语句
   CLOSED: [2013-02-23 Sat 17:18]
#+begin_src go
package main
import ("fmt"
)

func test() {
	entries := []string{"hello", "world"}
	for i, entry:= range entries {
		fmt.Print(i)
		fmt.Print(" "+entry+"\n")
	}

}
func main() {
	test()
}
#+end_src
** DONE [#B] golang defer可能会修改函数返回值
  CLOSED: [2013-02-19 Tue 16:37]
http://blog.golang.org/2010/08/defer-panic-and-recover.html#Blog1
#+begin_src go
package main
import ("fmt"
)

func c() (i int) {
    defer func() { i++ }()
    return 1
}

func main() {
	fmt.Println(c())
}

#+end_src
** DONE golang为什么下面代码创建的acl是0775, 而不是0777: 因为父目录不是777, 可通过syscall的unmask来解决
   CLOSED: [2013-07-25 Thu 22:09]
*** test code
#+begin_src go
package main
import ("fmt"
	"os"
)
func write_data(fname_data string, data string) bool {
	fmt.Printf("\n============ write file:" + fname_data+" ===============\n")
	f_data, err := os.OpenFile(fname_data, os.O_WRONLY | os.O_CREATE | os.O_TRUNC, 0777)
        if err != nil {
                panic(err)
        }
	defer f_data.Close()

	_, err = f_data.WriteString(data)
	if err != nil {
		panic(err)
	}

	return true
}

func main() {
	write_data("/tmp/test", "afdafd")
	fmt.Print("\nend\n")
}
#+end_src
*** console shot
#+begin_example
denny@denny-Vostro-1014:~$  go run ./test.go

============ write file:/tmp/test ===============

end
denny@denny-Vostro-1014:~$ ls -lt /tmp/test
-rwxrwxr-x 1 denny denny 6 Feb 18 14:08 /tmp/test
#+end_example
** [#A] golang Defer: commonly used to simplify functions that perform various clean-up actions.
** DONE go: undefined: sync.Pool: upgrade to go 1.3+
   CLOSED: [2017-06-13 Tue 11:22]
https://stackoverflow.com/questions/26236734/go-error-undefined-sync-pool-when-installing-go-mtpfs
In order to use the go-fuse library you'll need to use a Go version of at least 1.3.
** DONE package os/exec: unrecognized import path "os/exec" (import path does not begin with hostname)
   CLOSED: [2017-06-13 Tue 11:29]
https://groups.google.com/forum/#!topic/golang-nuts/ml3C0MuHNUI
C:\go\bin is not a valid GOROOT. Don't set GOROOT and you should be fine.
** TODO ubuntu upgrade google go
** #  --8<-------------------------- separator ------------------------>8-- :noexport:
** [#A] Goroutine是轻量级的并行程序执行路径,与线程,coroutine或者进程类似 :Important:
http://www.oschina.net/question/12_7902\\

#+begin_example


Goroutine是轻量级的并行程序执行路径,与线程,coroutine或者进程类似.然而,它们彼此相当不同,因此Go作者决定给它一个新的 名字并 放弃其它术语可能隐含的意义.

创建一个goroutine来运行名为DoThis的函数十分简单:

go DoThis() // but do not wait for it to complete

匿名的函数可以这样使用:

go func() {
 for { /* do something forever */ }
}() // Note that the function must be invoked

这些goroutine将会通过Go运行时而映射到适当的操作系统原语(比如,POSIX线程).
#+end_example
** 重要网页                                                        :noexport:
*** [#A] web page: The Go Programming Language Specification
#+BEGIN_EXAMPLE
http://golang.org/doc/go_spec.html\\
#+END_EXAMPLE
**** wecontent                                                     :noexport:
#+begin_example
Location: http://golang.org/doc/go_spec.html
The Go Programming Language

  * Home
  * Getting Started
  * Documentation
  * Contributing
  * Community

References: Packages | Commands | Specification

The Go Programming Language Specification

Version of July 14, 2011

Introduction

This is a reference manual for the Go programming language. For more information and other
documents, see http://golang.org.

Go is a general-purpose language designed with systems programming in mind. It is strongly typed
and garbage-collected and has explicit support for concurrent programming. Programs are constructed
from packages, whose properties allow efficient management of dependencies. The existing
implementations use a traditional compile/link model to generate executable binaries.

The grammar is compact and regular, allowing for easy analysis by automatic tools such as
integrated development environments.

Notation

The syntax is specified using Extended Backus-Naur Form (EBNF):

Production  = production_name "=" [ Expression ] "." .
Expression  = Alternative { "|" Alternative } .
Alternative = Term { Term } .
Term        = production_name | token [ "..." token ] | Group | Option | Repetition .
Group       = "(" Expression ")" .
Option      = "[" Expression "]" .
Repetition  = "{" Expression "}" .

Productions are expressions constructed from terms and the following operators, in increasing
precedence:

|   alternation
()  grouping
[]  option (0 or 1 times)
{}  repetition (0 to n times)

Lower-case production names are used to identify lexical tokens. Non-terminals are in CamelCase.
Lexical symbols are enclosed in double quotes "" or back quotes ``.

The form a ... b represents the set of characters from a through b as alternatives. The horizontal
ellipis ... is also used elsewhere in the spec to informally denote various enumerations or code
snippets that are not further specified. The character ... (as opposed to the three characters ...)
is not a token of the Go language.

Source code representation

Source code is Unicode text encoded in UTF-8. The text is not canonicalized, so a single accented
code point is distinct from the same character constructed from combining an accent and a letter;
those are treated as two code points. For simplicity, this document will use the term character to
refer to a Unicode code point.

Each code point is distinct; for instance, upper and lower case letters are different characters.

Implementation restriction: For compatibility with other tools, a compiler may disallow the NUL
character (U+0000) in the source text.

Characters

The following terms are used to denote specific Unicode character classes:

newline        = /* the Unicode code point U+000A */ .
unicode_char   = /* an arbitrary Unicode code point except newline */ .
unicode_letter = /* a Unicode code point classified as "Letter" */ .
unicode_digit  = /* a Unicode code point classified as "Decimal Digit" */ .

In The Unicode Standard 6.0, Section 4.5 "General Category" defines a set of character categories.
Go treats those characters in category Lu, Ll, Lt, Lm, or Lo as Unicode letters, and those in
category Nd as Unicode digits.

Letters and digits

The underscore character _ (U+005F) is considered a letter.

letter        = unicode_letter | "_" .
decimal_digit = "0" ... "9" .
octal_digit   = "0" ... "7" .
hex_digit     = "0" ... "9" | "A" ... "F" | "a" ... "f" .

Lexical elements

Comments

There are two forms of comments:

 1. Line comments start with the character sequence // and stop at the end of the line. A line
    comment acts like a newline.
 2. General comments start with the character sequence /* and continue through the character
    sequence */. A general comment that spans multiple lines acts like a newline, otherwise it acts
    like a space.

Comments do not nest.

Tokens

Tokens form the vocabulary of the Go language. There are four classes: identifiers, keywords,
operators and delimiters, and literals. White space, formed from spaces (U+0020), horizontal tabs
(U+0009), carriage returns (U+000D), and newlines (U+000A), is ignored except as it separates
tokens that would otherwise combine into a single token. Also, a newline or end of file may trigger
the insertion of a semicolon. While breaking the input into tokens, the next token is the longest
sequence of characters that form a valid token.

Semicolons

The formal grammar uses semicolons ";" as terminators in a number of productions. Go programs may
omit most of these semicolons using the following two rules:

 1. When the input is broken into tokens, a semicolon is automatically inserted into the token
    stream at the end of a non-blank line if the line's final token is

      + an identifier
      + an integer, floating-point, imaginary, character, or string literal
      + one of the keywords break, continue, fallthrough, or return
      + one of the operators and delimiters ++, --, ), ], or }
 2. To allow complex statements to occupy a single line, a semicolon may be omitted before a
    closing ")" or "}".

To reflect idiomatic use, code examples in this document elide semicolons using these rules.

Identifiers

Identifiers name program entities such as variables and types. An identifier is a sequence of one
or more letters and digits. The first character in an identifier must be a letter.

identifier = letter { letter | unicode_digit } .

a
_x9
ThisVariableIsExported
αβ

Some identifiers are predeclared.

Keywords

The following keywords are reserved and may not be used as identifiers.

break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var

Operators and Delimiters

The following character sequences represent operators, delimiters, and other special tokens:

+    &     +=    &=     &&    ==    !=    (    )
-    |     -=    |=     ||    <     <=    [    ]
#    ^     *=    ^=     <-    >     >=    {    }
/    <<    /=    <<=    ++    =     :=    ,    ;
%    >>    %=    >>=    --    !     ...   .    :
     &^          &^=

Integer literals

An integer literal is a sequence of digits representing an integer constant. An optional prefix
sets a non-decimal base: 0 for octal, 0x or 0X for hexadecimal. In hexadecimal literals, letters
a-f and A-F represent values 10 through 15.

int_lit     = decimal_lit | octal_lit | hex_lit .
decimal_lit = ( "1" ... "9" ) { decimal_digit } .
octal_lit   = "0" { octal_digit } .
hex_lit     = "0" ( "x" | "X" ) hex_digit { hex_digit } .

42
0600
0xBadFace
170141183460469231731687303715884105727

Floating-point literals

A floating-point literal is a decimal representation of a floating-point constant. It has an
integer part, a decimal point, a fractional part, and an exponent part. The integer and fractional
part comprise decimal digits; the exponent part is an e or E followed by an optionally signed
decimal exponent. One of the integer part or the fractional part may be elided; one of the decimal
point or the exponent may be elided.

float_lit = decimals "." [ decimals ] [ exponent ] |
            decimals exponent |
            "." decimals [ exponent ] .
decimals  = decimal_digit { decimal_digit } .
exponent  = ( "e" | "E" ) [ "+" | "-" ] decimals .

0.
72.40
072.40  // == 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5

Imaginary literals

An imaginary literal is a decimal representation of the imaginary part of a complex constant. It
consists of a floating-point literal or decimal integer followed by the lower-case letter i.

imaginary_lit = (decimals | float_lit) "i" .

0i
011i  // == 11i
0.i
2.71828i
1.e+0i
6.67428e-11i
1E6i
.25i
.12345E+5i

Character literals

A character literal represents an integer constant, typically a Unicode code point, as one or more
characters enclosed in single quotes. Within the quotes, any character may appear except single
quote and newline. A single quoted character represents itself, while multi-character sequences
beginning with a backslash encode values in various formats.

The simplest form represents the single character within the quotes; since Go source text is
Unicode characters encoded in UTF-8, multiple UTF-8-encoded bytes may represent a single integer
value. For instance, the literal 'a' holds a single byte representing a literal a, Unicode U+0061,
value 0x61, while 'ä' holds two bytes (0xc3 0xa4) representing a literal a-dieresis, U+00E4, value
0xe4.

Several backslash escapes allow arbitrary values to be represented as ASCII text. There are four
ways to represent the integer value as a numeric constant: \x followed by exactly two hexadecimal
digits; \u followed by exactly four hexadecimal digits; \U followed by exactly eight hexadecimal
digits, and a plain backslash \ followed by exactly three octal digits. In each case the value of
the literal is the value represented by the digits in the corresponding base.

Although these representations all result in an integer, they have different valid ranges. Octal
escapes must represent a value between 0 and 255 inclusive. Hexadecimal escapes satisfy this
condition by construction. The escapes \u and \U represent Unicode code points so within them some
values are illegal, in particular those above 0x10FFFF and surrogate halves.

After a backslash, certain single-character escapes represent special values:

\a   U+0007 alert or bell
\b   U+0008 backspace
\f   U+000C form feed
\n   U+000A line feed or newline
\r   U+000D carriage return
\t   U+0009 horizontal tab
\v   U+000b vertical tab
\\   U+005c backslash
\'   U+0027 single quote  (valid escape only within character literals)
\"   U+0022 double quote  (valid escape only within string literals)

All other sequences starting with a backslash are illegal inside character literals.

char_lit         = "'" ( unicode_value | byte_value ) "'" .
unicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .
byte_value       = octal_byte_value | hex_byte_value .
octal_byte_value = `\` octal_digit octal_digit octal_digit .
hex_byte_value   = `\` "x" hex_digit hex_digit .
little_u_value   = `\` "u" hex_digit hex_digit hex_digit hex_digit .
big_u_value      = `\` "U" hex_digit hex_digit hex_digit hex_digit
                           hex_digit hex_digit hex_digit hex_digit .
escaped_char     = `\` ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | `\` | "'" | `"` ) .

'a'
'ä'
'本'
'\t'
'\000'
'\007'
'\377'
'\x07'
'\xff'
'\u12e4'
'\U00101234'

String literals

A string literal represents a string constant obtained from concatenating a sequence of characters.
There are two forms: raw string literals and interpreted string literals.

Raw string literals are character sequences between back quotes ``. Within the quotes, any
character is legal except back quote. The value of a raw string literal is the string composed of
the uninterpreted characters between the quotes; in particular, backslashes have no special meaning
and the string may span multiple lines.

Interpreted string literals are character sequences between double quotes "". The text between the
quotes, which may not span multiple lines, forms the value of the literal, with backslash escapes
interpreted as they are in character literals (except that \' is illegal and \" is legal). The
three-digit octal (\nnn) and two-digit hexadecimal (\xnn) escapes represent individual bytes of the
resulting string; all other escapes represent the (possibly multi-byte) UTF-8 encoding of
individual characters. Thus inside a string literal \377 and \xFF represent a single byte of value
0xFF=255, while ÿ, \u00FF, \U000000FF and \xc3\xbf represent the two bytes 0xc3 0xbf of the UTF-8
encoding of character U+00FF.

string_lit             = raw_string_lit | interpreted_string_lit .
raw_string_lit         = "`" { unicode_char | newline } "`" .
interpreted_string_lit = `"` { unicode_value | byte_value } `"` .

`abc`  // same as "abc"
`\n
\n`    // same as "\\n\n\\n"
"\n"
""
"Hello, world!\n"
"日本語"
"\u65e5本\U00008a9e"
"\xff\u00FF"

These examples all represent the same string:

"日本語"                                 // UTF-8 input text
`日本語`                                 // UTF-8 input text as a raw literal
"\u65e5\u672c\u8a9e"                    // The explicit Unicode code points
"\U000065e5\U0000672c\U00008a9e"        // The explicit Unicode code points
"\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e"  // The explicit UTF-8 bytes

If the source code represents a character as two code points, such as a combining form involving an
accent and a letter, the result will be an error if placed in a character literal (it is not a
single code point), and will appear as two code points if placed in a string literal.

Constants

There are boolean constants, integer constants, floating-point constants, complex constants, and
string constants. Integer, floating-point, and complex constants are collectively called numeric
constants.

A constant value is represented by an integer, floating-point, imaginary, character, or string
literal, an identifier denoting a constant, a constant expression, a conversion with a result that
is a constant, or the result value of some built-in functions such as unsafe.Sizeof applied to any
value, cap or len applied to some expressions, real and imag applied to a complex constant and
complex applied to numeric constants. The boolean truth values are represented by the predeclared
constants true and false. The predeclared identifier iota denotes an integer constant.

In general, complex constants are a form of constant expression and are discussed in that section.

Numeric constants represent values of arbitrary precision and do not overflow.

Constants may be typed or untyped. Literal constants, true, false, iota, and certain constant
expressions containing only untyped constant operands are untyped.

A constant may be given a type explicitly by a constant declaration or conversion, or implicitly
when used in a variable declaration or an assignment or as an operand in an expression. It is an
error if the constant value cannot be represented as a value of the respective type. For instance,
3.0 can be given any integer or any floating-point type, while 2147483648.0 (equal to 1<<31) can be
given the types float32, float64, or uint32 but not int32 or string.

There are no constants denoting the IEEE-754 infinity and not-a-number values, but the math package
's Inf, NaN, IsInf, and IsNaN functions return and test for those values at run time.

Implementation restriction: A compiler may implement numeric constants by choosing an internal
representation with at least twice as many bits as any machine type; for floating-point values,
both the mantissa and exponent must be twice as large.

Types

A type determines the set of values and operations specific to values of that type. A type may be
specified by a (possibly qualified) type name (§Qualified identifier, §Type declarations) or a type
literal, which composes a new type from previously declared types.

Type      = TypeName | TypeLit | "(" Type ")" .
TypeName  = QualifiedIdent .
TypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType |
        SliceType | MapType | ChannelType .

Named instances of the boolean, numeric, and string types are predeclared. Composite types-array,
struct, pointer, function, interface, slice, map, and channel types-may be constructed using type
literals.

The static type (or just type) of a variable is the type defined by its declaration. Variables of
interface type also have a distinct dynamic type, which is the actual type of the value stored in
the variable at run-time. The dynamic type may vary during execution but is always assignable to
the static type of the interface variable. For non-interface types, the dynamic type is always the
static type.

Each type T has an underlying type: If T is a predeclared type or a type literal, the corresponding
underlying type is T itself. Otherwise, T's underlying type is the underlying type of the type to
which T refers in its type declaration.

   type T1 string
   type T2 T1
   type T3 []T1
   type T4 T3

The underlying type of string, T1, and T2 is string. The underlying type of []T1, T3, and T4 is []
T1.

Method sets

A type may have a method set associated with it (§Interface types, §Method declarations). The
method set of an interface type is its interface. The method set of any other named type T consists
of all methods with receiver type T. The method set of the corresponding pointer type *T is the set
of all methods with receiver *T or T (that is, it also contains the method set of T). Any other
type has an empty method set. In a method set, each method must have a unique name.

Boolean types

A boolean type represents the set of Boolean truth values denoted by the predeclared constants true
and false. The predeclared boolean type is bool.

Numeric types

A numeric type represents sets of integer or floating-point values. The predeclared
architecture-independent numeric types are:

uint8       the set of all unsigned  8-bit integers (0 to 255)
uint16      the set of all unsigned 16-bit integers (0 to 65535)
uint32      the set of all unsigned 32-bit integers (0 to 4294967295)
uint64      the set of all unsigned 64-bit integers (0 to 18446744073709551615)

int8        the set of all signed  8-bit integers (-128 to 127)
int16       the set of all signed 16-bit integers (-32768 to 32767)
int32       the set of all signed 32-bit integers (-2147483648 to 2147483647)
int64       the set of all signed 64-bit integers (-9223372036854775808 to 9223372036854775807)

float32     the set of all IEEE-754 32-bit floating-point numbers
float64     the set of all IEEE-754 64-bit floating-point numbers

complex64   the set of all complex numbers with float32 real and imaginary parts
complex128  the set of all complex numbers with float64 real and imaginary parts

byte        familiar alias for uint8

The value of an n-bit integer is n bits wide and represented using two's complement arithmetic.

There is also a set of predeclared numeric types with implementation-specific sizes:

uint     either 32 or 64 bits
int      same size as uint
uintptr  an unsigned integer large enough to store the uninterpreted bits of a pointer value

To avoid portability issues all numeric types are distinct except byte, which is an alias for
uint8. Conversions are required when different numeric types are mixed in an expression or
assignment. For instance, int32 and int are not the same type even though they may have the same
size on a particular architecture.

String types

A string type represents the set of string values. Strings behave like arrays of bytes but are
immutable: once created, it is impossible to change the contents of a string. The predeclared
string type is string.

The elements of strings have type byte and may be accessed using the usual indexing operations. It
is illegal to take the address of such an element; if s[i] is the ith byte of a string, &s[i] is
invalid. The length of string s can be discovered using the built-in function len. The length is a
compile-time constant if s is a string literal.

Array types

An array is a numbered sequence of elements of a single type, called the element type. The number
of elements is called the length and is never negative.

ArrayType   = "[" ArrayLength "]" ElementType .
ArrayLength = Expression .
ElementType = Type .

The length is part of the array's type and must be a constant expression that evaluates to a
non-negative integer value. The length of array a can be discovered using the built-in function len
(a). The elements can be indexed by integer indices 0 through the len(a)-1 (§Indexes). Array types
are always one-dimensional but may be composed to form multi-dimensional types.

[32]byte
[2*N] struct { x, y int32 }
[1000]*float64
[3][5]int
[2][2][2]float64  // same as [2]([2]([2]float64))

Slice types

A slice is a reference to a contiguous segment of an array and contains a numbered sequence of
elements from that array. A slice type denotes the set of all slices of arrays of its element type.
The value of an uninitialized slice is nil.

SliceType = "[" "]" ElementType .

Like arrays, slices are indexable and have a length. The length of a slice s can be discovered by
the built-in function len(s); unlike with arrays it may change during execution. The elements can
be addressed by integer indices 0 through len(s)-1 (§Indexes). The slice index of a given element
may be less than the index of the same element in the underlying array.

A slice, once initialized, is always associated with an underlying array that holds its elements. A
slice therefore shares storage with its array and with other slices of the same array; by contrast,
distinct arrays always represent distinct storage.

The array underlying a slice may extend past the end of the slice. The capacity is a measure of
that extent: it is the sum of the length of the slice and the length of the array beyond the slice;
a slice of length up to that capacity can be created by `slicing' a new one from the original slice
(§Slices). The capacity of a slice a can be discovered using the built-in function cap(a).

A new, initialized slice value for a given element type T is made using the built-in function make,
which takes a slice type and parameters specifying the length and optionally the capacity:

make([]T, length)
make([]T, length, capacity)

A call to make allocates a new, hidden array to which the returned slice value refers. That is,
executing

make([]T, length, capacity)

produces the same slice as allocating an array and slicing it, so these two examples result in the
same slice:

make([]int, 50, 100)
new([100]int)[0:50]

Like arrays, slices are always one-dimensional but may be composed to construct higher-dimensional
objects. With arrays of arrays, the inner arrays are, by construction, always the same length;
however with slices of slices (or arrays of slices), the lengths may vary dynamically. Moreover,
the inner slices must be allocated individually (with make).

Struct types

A struct is a sequence of named elements, called fields, each of which has a name and a type. Field
names may be specified explicitly (IdentifierList) or implicitly (AnonymousField). Within a struct,
non-blank field names must be unique.

StructType     = "struct" "{" { FieldDecl ";" } "}" .
FieldDecl      = (IdentifierList Type | AnonymousField) [ Tag ] .
AnonymousField = [ "*" ] TypeName .
Tag            = string_lit .

// An empty struct.
struct {}

// A struct with 6 fields.
struct {
    x, y int
    u float32
    _ float32  // padding
    A *[]int
    F func()
}

A field declared with a type but no explicit field name is an anonymous field (colloquially called
an embedded field). Such a field type must be specified as a type name T or as a pointer to a
non-interface type name *T, and T itself may not be a pointer type. The unqualified type name acts
as the field name.

// A struct with four anonymous fields of type T1, *T2, P.T3 and *P.T4
struct {
    T1        // field name is T1
    *T2       // field name is T2
    P.T3      // field name is T3
    *P.T4     // field name is T4
    x, y int  // field names are x and y
}

The following declaration is illegal because field names must be unique in a struct type:

struct {
    T         // conflicts with anonymous field *T and *P.T
    *T        // conflicts with anonymous field T and *P.T
    *P.T      // conflicts with anonymous field T and *T
}

Fields and methods (§Method declarations) of an anonymous field are promoted to be ordinary fields
and methods of the struct (§Selectors). The following rules apply for a struct type named S and a
type named T:

  * If S contains an anonymous field T, the method set of S includes the method set of T.
  * If S contains an anonymous field *T, the method set of S includes the method set of *T (which
    itself includes the method set of T).
  * If S contains an anonymous field T or *T, the method set of *S includes the method set of *T
    (which itself includes the method set of T).

A field declaration may be followed by an optional string literal tag, which becomes an attribute
for all the fields in the corresponding field declaration. The tags are made visible through a
reflection interface but are otherwise ignored.

// A struct corresponding to the TimeStamp protocol buffer.
// The tag strings define the protocol buffer field numbers.
struct {
    microsec  uint64 "field 1"
    serverIP6 uint64 "field 2"
    process   string "field 3"
}

Pointer types

A pointer type denotes the set of all pointers to variables of a given type, called the base type
of the pointer. The value of an uninitialized pointer is nil.

PointerType = "*" BaseType .
BaseType = Type .
*int
*map[string] *chan int
Function types

A function type denotes the set of all functions with the same parameter and result types. The
value of an uninitialized variable of function type is nil.

FunctionType   = "func" Signature .
Signature      = Parameters [ Result ] .
Result         = Parameters | Type .
Parameters     = "(" [ ParameterList [ "," ] ] ")" .
ParameterList  = ParameterDecl { "," ParameterDecl } .
ParameterDecl  = [ IdentifierList ] [ "..." ] Type .

Within a list of parameters or results, the names (IdentifierList) must either all be present or
all be absent. If present, each name stands for one item (parameter or result) of the specified
type; if absent, each type stands for one item of that type. Parameter and result lists are always
parenthesized except that if there is exactly one unnamed result it may be written as an
unparenthesized type.

The final parameter in a function signature may have a type prefixed with .... A function with such
a parameter is called variadic and may be invoked with zero or more arguments for that parameter.

func()
func(x int)
func() int
func(prefix string, values ...int)
func(a, b int, z float32) bool
func(a, b int, z float32) (bool)
func(a, b int, z float64, opt ...interface{}) (success bool)
func(int, int, float64) (float64, *[]int)
func(n int) func(p *T)

Interface types

An interface type specifies a method set called its interface. A variable of interface type can
store a value of any type with a method set that is any superset of the interface. Such a type is
said to implement the interface. The value of an uninitialized variable of interface type is nil.

InterfaceType      = "interface" "{" { MethodSpec ";" } "}" .
MethodSpec         = MethodName Signature | InterfaceTypeName .
MethodName         = identifier .
InterfaceTypeName  = TypeName .

As with all method sets, in an interface type, each method must have a unique name.

// A simple File interface
interface {
    Read(b Buffer) bool
    Write(b Buffer) bool
    Close()
}

More than one type may implement an interface. For instance, if two types S1 and S2 have the method
set

func (p T) Read(b Buffer) bool { return ... }
func (p T) Write(b Buffer) bool { return ... }
func (p T) Close() { ... }

(where T stands for either S1 or S2) then the File interface is implemented by both S1 and S2,
regardless of what other methods S1 and S2 may have or share.

A type implements any interface comprising any subset of its methods and may therefore implement
several distinct interfaces. For instance, all types implement the empty interface:

interface{}

Similarly, consider this interface specification, which appears within a type declaration to define
an interface called Lock:

type Lock interface {
    Lock()
    Unlock()
}

If S1 and S2 also implement

func (p T) Lock() { ... }
func (p T) Unlock() { ... }

they implement the Lock interface as well as the File interface.

An interface may contain an interface type name T in place of a method specification. The effect is
equivalent to enumerating the methods of T explicitly in the interface.

type ReadWrite interface {
    Read(b Buffer) bool
    Write(b Buffer) bool
}

type File interface {
    ReadWrite  // same as enumerating the methods in ReadWrite
    Lock       // same as enumerating the methods in Lock
    Close()
}

Map types

A map is an unordered group of elements of one type, called the element type, indexed by a set of
unique keys of another type, called the key type. The value of an uninitialized map is nil.

MapType     = "map" "[" KeyType "]" ElementType .
KeyType     = Type .

The comparison operators == and != (§Comparison operators) must be fully defined for operands of
the key type; thus the key type must not be a struct, array or slice. If the key type is an
interface type, these comparison operators must be defined for the dynamic key values; failure will
cause a run-time panic.

map [string] int
map [*T] struct { x, y float64 }
map [string] interface {}

The number of map elements is called its length. For a map m, it can be discovered using the
built-in function len(m) and may change during execution. Elements may be added and removed during
execution using special forms of assignment; and they may be accessed with index expressions.

A new, empty map value is made using the built-in function make, which takes the map type and an
optional capacity hint as arguments:

make(map[string] int)
make(map[string] int, 100)

The initial capacity does not bound its size: maps grow to accommodate the number of items stored
in them, with the exception of nil maps. A nil map is equivalent to an empty map except that no
elements may be added.

Channel types

A channel provides a mechanism for two concurrently executing functions to synchronize execution
and communicate by passing a value of a specified element type. The value of an uninitialized
channel is nil.

ChannelType = ( "chan" [ "<-" ] | "<-" "chan" ) ElementType .

The <- operator specifies the channel direction, send or receive. If no direction is given, the
channel is bi-directional. A channel may be constrained only to send or only to receive by
conversion or assignment.

chan T         // can be used to send and receive values of type T
chan<- float64 // can only be used to send float64s
<-chan int     // can only be used to receive ints

The <- operator associates with the leftmost chan possible:

chan<- chan int     // same as chan<- (chan int)
chan<- <-chan int   // same as chan<- (<-chan int)
<-chan <-chan int   // same as <-chan (<-chan int)
chan (<-chan int)

A new, initialized channel value can be made using the built-in function make, which takes the
channel type and an optional capacity as arguments:

make(chan int, 100)

The capacity, in number of elements, sets the size of the buffer in the channel. If the capacity is
greater than zero, the channel is asynchronous: communication operations succeed without blocking
if the buffer is not full (sends) or not empty (receives), and elements are received in the order
they are sent. If the capacity is zero or absent, the communication succeeds only when both a
sender and receiver are ready. A nil channel is never ready for communication.

A channel may be closed with the built-in function close; the multi-valued assignment form of the
receive operator tests whether a channel has been closed.

Properties of types and values

Type identity

Two types are either identical or different.

Two named types are identical if their type names originate in the same type declaration. A named
and an unnamed type are always different. Two unnamed types are identical if the corresponding type
literals are identical, that is, if they have the same literal structure and corresponding
components have identical types. In detail:

  * Two array types are identical if they have identical element types and the same array length.
  * Two slice types are identical if they have identical element types.
  * Two struct types are identical if they have the same sequence of fields, and if corresponding
    fields have the same names, and identical types, and identical tags. Two anonymous fields are
    considered to have the same name. Lower-case field names from different packages are always
    different.
  * Two pointer types are identical if they have identical base types.
  * Two function types are identical if they have the same number of parameters and result values,
    corresponding parameter and result types are identical, and either both functions are variadic
    or neither is. Parameter and result names are not required to match.
  * Two interface types are identical if they have the same set of methods with the same names and
    identical function types. Lower-case method names from different packages are always different.
    The order of the methods is irrelevant.
  * Two map types are identical if they have identical key and value types.
  * Two channel types are identical if they have identical value types and the same direction.

Given the declarations

type (
    T0 []string
    T1 []string
    T2 struct { a, b int }
    T3 struct { a, c int }
    T4 func(int, float64) *T0
    T5 func(x int, y float64) *[]string
)

these types are identical:

T0 and T0
[]int and []int
struct { a, b *T5 } and struct { a, b *T5 }
func(x int, y float64) *[]string and func(int, float64) (result *[]string)

T0 and T1 are different because they are named types with distinct declarations; func(int, float64)
*T0 and func(x int, y float64) *[]string are different because T0 is different from []string.
Assignability

A value x is assignable to a variable of type T ("x is assignable to T") in any of these cases:

  * x's type is identical to T.
  * x's type V and T have identical underlying types and at least one of V or T is not a named
    type.
  * T is an interface type and x implements T.
  * x is a bidirectional channel value, T is a channel type, x's type V and T have identical
    element types, and at least one of V or T is not a named type.
  * x is the predeclared identifier nil and T is a pointer, function, slice, map, channel, or
    interface type.
  * x is an untyped constant representable by a value of type T.

If T is a struct type with non-exported fields, the assignment must be in the same package in which
T is declared, or x must be the receiver of a method call. In other words, a struct value can be
assigned to a struct variable only if every field of the struct may be legally assigned
individually by the program, or if the assignment is initializing the receiver of a method of the
struct type.

Any value may be assigned to the blank identifier.

Blocks

A block is a sequence of declarations and statements within matching brace brackets.

Block = "{" { Statement ";" } "}" .

In addition to explicit blocks in the source code, there are implicit blocks:

 1. The universe block encompasses all Go source text.
 2. Each package has a package block containing all Go source text for that package.
 3. Each file has a file block containing all Go source text in that file.
 4. Each if, for, and switch statement is considered to be in its own implicit block.
 5. Each clause in a switch or select statement acts as an implicit block.

Blocks nest and influence scoping.

Declarations and scope

A declaration binds a non-blank identifier to a constant, type, variable, function, or package.
Every identifier in a program must be declared. No identifier may be declared twice in the same
block, and no identifier may be declared in both the file and package block.

Declaration   = ConstDecl | TypeDecl | VarDecl .
TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .

The scope of a declared identifier is the extent of source text in which the identifier denotes the
specified constant, type, variable, function, or package.

Go is lexically scoped using blocks:

 1. The scope of a predeclared identifier is the universe block.
 2. The scope of an identifier denoting a constant, type, variable, or function (but not method)
    declared at top level (outside any function) is the package block.
 3. The scope of an imported package identifier is the file block of the file containing the import
    declaration.
 4. The scope of an identifier denoting a function parameter or result variable is the function
    body.
 5. The scope of a constant or variable identifier declared inside a function begins at the end of
    the ConstSpec or VarSpec (ShortVarDecl for short variable declarations) and ends at the end of
    the innermost containing block.
 6. The scope of a type identifier declared inside a function begins at the identifier in the
    TypeSpec and ends at the end of the innermost containing block.

An identifier declared in a block may be redeclared in an inner block. While the identifier of the
inner declaration is in scope, it denotes the entity declared by the inner declaration.

The package clause is not a declaration; the package name does not appear in any scope. Its purpose
is to identify the files belonging to the same package and to specify the default package name for
import declarations.

Label scopes

Labels are declared by labeled statements and are used in the break, continue, and goto statements
(§Break statements, §Continue statements, §Goto statements). It is illegal to define a label that
is never used. In contrast to other identifiers, labels are not block scoped and do not conflict
with identifiers that are not labels. The scope of a label is the body of the function in which it
is declared and excludes the body of any nested function.

Predeclared identifiers

The following identifiers are implicitly declared in the universe block:

Basic types:
    bool byte complex64 complex128 float32 float64
    int8 int16 int32 int64 string uint8 uint16 uint32 uint64

Architecture-specific convenience types:
    int uint uintptr

Constants:
    true false iota

Zero value:
    nil

Functions:
    append cap close complex copy imag len
    make new panic print println real recover

Exported identifiers

An identifier may be exported to permit access to it from another package using a qualified
identifier. An identifier is exported if both:

 1. the first character of the identifier's name is a Unicode upper case letter (Unicode class
    "Lu"); and
 2. the identifier is declared in the package block or denotes a field or method of a type declared
    in that block.

All other identifiers are not exported.

Blank identifier

The blank identifier, represented by the underscore character _, may be used in a declaration like
any other identifier but the declaration does not introduce a new binding.

Constant declarations

A constant declaration binds a list of identifiers (the names of the constants) to the values of a
list of constant expressions. The number of identifiers must be equal to the number of expressions,
and the nth identifier on the left is bound to the value of the nth expression on the right.

ConstDecl      = "const" ( ConstSpec | "(" { ConstSpec ";" } ")" ) .
ConstSpec      = IdentifierList [ [ Type ] "=" ExpressionList ] .

IdentifierList = identifier { "," identifier } .
ExpressionList = Expression { "," Expression } .

If the type is present, all constants take the type specified, and the expressions must be
assignable to that type. If the type is omitted, the constants take the individual types of the
corresponding expressions. If the expression values are untyped constants, the declared constants
remain untyped and the constant identifiers denote the constant values. For instance, if the
expression is a floating-point literal, the constant identifier denotes a floating-point constant,
even if the literal's fractional part is zero.

const Pi float64 = 3.14159265358979323846
const zero = 0.0             // untyped floating-point constant
const (
    size int64 = 1024
    eof = -1             // untyped integer constant
)
const a, b, c = 3, 4, "foo"  // a = 3, b = 4, c = "foo", untyped integer and string constants
const u, v float32 = 0, 3    // u = 0.0, v = 3.0

Within a parenthesized const declaration list the expression list may be omitted from any but the
first declaration. Such an empty list is equivalent to the textual substitution of the first
preceding non-empty expression list and its type if any. Omitting the list of expressions is
therefore equivalent to repeating the previous list. The number of identifiers must be equal to the
number of expressions in the previous list. Together with the iota constant generator this
mechanism permits light-weight declaration of sequential values:

const (
    Sunday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Partyday
    numberOfDays  // this constant is not exported
)

Iota

Within a constant declaration, the predeclared identifier iota represents successive untyped
integer constants. It is reset to 0 whenever the reserved word const appears in the source and
increments after each ConstSpec. It can be used to construct a set of related constants:

const (  // iota is reset to 0
    c0 = iota  // c0 == 0
    c1 = iota  // c1 == 1
    c2 = iota  // c2 == 2
)

const (
    a = 1 << iota  // a == 1 (iota has been reset)
    b = 1 << iota  // b == 2
    c = 1 << iota  // c == 4
)

const (
    u         = iota * 42  // u == 0     (untyped integer constant)
    v float64 = iota * 42  // v == 42.0  (float64 constant)
    w         = iota * 42  // w == 84    (untyped integer constant)
)

const x = iota  // x == 0 (iota has been reset)
const y = iota  // y == 0 (iota has been reset)

Within an ExpressionList, the value of each iota is the same because it is only incremented after
each ConstSpec:

const (
    bit0, mask0 = 1 << iota, 1 << iota - 1  // bit0 == 1, mask0 == 0
    bit1, mask1                             // bit1 == 2, mask1 == 1
    _, _                                    // skips iota == 2
    bit3, mask3                             // bit3 == 8, mask3 == 7
)

This last example exploits the implicit repetition of the last non-empty expression list.

Type declarations

A type declaration binds an identifier, the type name, to a new type that has the same underlying
type as an existing type. The new type is different from the existing type.

TypeDecl     = "type" ( TypeSpec | "(" { TypeSpec ";" } ")" ) .
TypeSpec     = identifier Type .

type IntArray [16]int

type (
    Point struct { x, y float64 }
    Polar Point
)

type TreeNode struct {
    left, right *TreeNode
    value *Comparable
}

type Cipher interface {
    BlockSize() int
    Encrypt(src, dst []byte)
    Decrypt(src, dst []byte)
}

The declared type does not inherit any methods bound to the existing type, but the method set of an
interface type or of elements of a composite type remains unchanged:

// A Mutex is a data type with two methods, Lock and Unlock.
type Mutex struct         { /* Mutex fields */ }
func (m *Mutex) Lock()    { /* Lock implementation */ }
func (m *Mutex) Unlock()  { /* Unlock implementation */ }

// NewMutex has the same composition as Mutex but its method set is empty.
type NewMutex Mutex

// The method set of the base type of PtrMutex remains unchanged,
// but the method set of PtrMutex is empty.
type PtrMutex *Mutex

// The method set of *PrintableMutex contains the methods
// Lock and Unlock bound to its anonymous field Mutex.
type PrintableMutex struct {
    Mutex
}

// MyCipher is an interface type that has the same method set as Cipher.
type MyCipher Cipher

A type declaration may be used to define a different boolean, numeric, or string type and attach
methods to it:

type TimeZone int

const (
    EST TimeZone = -(5 + iota)
    CST
    MST
    PST
)

func (tz TimeZone) String() string {
    return fmt.Sprintf("GMT+%dh", tz)
}

Variable declarations

A variable declaration creates a variable, binds an identifier to it and gives it a type and
optionally an initial value.

VarDecl     = "var" ( VarSpec | "(" { VarSpec ";" } ")" ) .
VarSpec     = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .

var i int
var U, V, W float64
var k = 0
var x, y float32 = -1, -2
var (
    i int
    u, v, s = 2.0, 3.0, "bar"
)
var re, im = complexSqrt(-1)
var _, found = entries[name]  // map lookup; only interested in "found"

If a list of expressions is given, the variables are initialized by assigning the expressions to
the variables (§Assignments) in order; all expressions must be consumed and all variables
initialized from them. Otherwise, each variable is initialized to its zero value.

If the type is present, each variable is given that type. Otherwise, the types are deduced from the
assignment of the expression list.

If the type is absent and the corresponding expression evaluates to an untyped constant, the type
of the declared variable is bool, int, float64, or string respectively, depending on whether the
value is a boolean, integer, floating-point, or string constant:

var b = true    // t has type bool
var i = 0       // i has type int
var f = 3.0     // f has type float64
var s = "OMDB"  // s has type string

Short variable declarations

A short variable declaration uses the syntax:

ShortVarDecl = IdentifierList ":=" ExpressionList .

It is a shorthand for a regular variable declaration with initializer expressions but no types:

"var" IdentifierList = ExpressionList .

i, j := 0, 10
f := func() int { return 7 }
ch := make(chan int)
r, w := os.Pipe(fd)  // os.Pipe() returns two values
_, y, _ := coord(p)  // coord() returns three values; only interested in y coordinate

Unlike regular variable declarations, a short variable declaration may redeclare variables provided
they were originally declared in the same block with the same type, and at least one of the non-
blank variables is new. As a consequence, redeclaration can only appear in a multi-variable short
declaration. Redeclaration does not introduce a new variable; it just assigns a new value to the
original.

field1, offset := nextField(str, 0)
field2, offset := nextField(str, offset)  // redeclares offset

Short variable declarations may appear only inside functions. In some contexts such as the
initializers for if, for, or switch statements, they can be used to declare local temporary
variables (§Statements).

Function declarations

A function declaration binds an identifier to a function (§Function types).

FunctionDecl = "func" identifier Signature [ Body ] .
Body         = Block .

A function declaration may omit the body. Such a declaration provides the signature for a function
implemented outside Go, such as an assembly routine.

func min(x int, y int) int {
    if x < y {
        return x
    }
    return y
}

func flushICache(begin, end uintptr)  // implemented externally

Method declarations

A method is a function with a receiver. A method declaration binds an identifier to a method.

MethodDecl   = "func" Receiver MethodName Signature [ Body ] .
Receiver     = "(" [ identifier ] [ "*" ] BaseTypeName ")" .
BaseTypeName = identifier .

The receiver type must be of the form T or *T where T is a type name. T is called the receiver base
type or just base type. The base type must not be a pointer or interface type and must be declared
in the same package as the method. The method is said to be bound to the base type and is visible
only within selectors for that type (§Type declarations, §Selectors).

Given type Point, the declarations

func (p *Point) Length() float64 {
    return math.Sqrt(p.x * p.x + p.y * p.y)
}

func (p *Point) Scale(factor float64) {
    p.x *= factor
    p.y *= factor
}

bind the methods Length and Scale, with receiver type *Point, to the base type Point.

If the receiver's value is not referenced inside the body of the method, its identifier may be
omitted in the declaration. The same applies in general to parameters of functions and methods.

The type of a method is the type of a function with the receiver as first argument. For instance,
the method Scale has type

func(p *Point, factor float64)

However, a function declared this way is not a method.

Expressions

An expression specifies the computation of a value by applying operators and functions to operands.

Operands

Operands denote the elementary values in an expression.

Operand    = Literal | QualifiedIdent | MethodExpr | "(" Expression ")" .
Literal    = BasicLit | CompositeLit | FunctionLit .
BasicLit   = int_lit | float_lit | imaginary_lit | char_lit | string_lit .

Qualified identifiers

A qualified identifier is a non-blank identifier qualified by a package name prefix.

QualifiedIdent = [ PackageName "." ] identifier .

A qualified identifier accesses an identifier in a separate package. The identifier must be
exported by that package, which means that it must begin with a Unicode upper case letter.

math.Sin

Composite literals

Composite literals construct values for structs, arrays, slices, and maps and create a new value
each time they are evaluated. They consist of the type of the value followed by a brace-bound list
of composite elements. An element may be a single expression or a key-value pair.

CompositeLit  = LiteralType LiteralValue .
LiteralType   = StructType | ArrayType | "[" "..." "]" ElementType |
                SliceType | MapType | TypeName .
LiteralValue  = "{" [ ElementList [ "," ] ] "}" .
ElementList   = Element { "," Element } .
Element       = [ Key ":" ] Value .
Key           = FieldName | ElementIndex .
FieldName     = identifier .
ElementIndex  = Expression .
Value         = Expression | LiteralValue .

The LiteralType must be a struct, array, slice, or map type (the grammar enforces this constraint
except when the type is given as a TypeName). The types of the expressions must be assignable to
the respective field, element, and key types of the LiteralType; there is no additional conversion.
The key is interpreted as a field name for struct literals, an index expression for array and slice
literals, and a key for map literals. For map literals, all elements must have a key. It is an
error to specify multiple elements with the same field name or constant key value.

For struct literals the following rules apply:

  * A key must be a field name declared in the LiteralType.
  * A literal that does not contain any keys must list an element for each struct field in the
    order in which the fields are declared.
  * If any element has a key, every element must have a key.
  * A literal that contains keys does not need to have an element for each struct field. Omitted
    fields get the zero value for that field.
  * A literal may omit the element list; such a literal evaluates to the zero value for its type.
  * It is an error to specify an element for a non-exported field of a struct belonging to a
    different package.

Given the declarations

type Point3D struct { x, y, z float64 }
type Line struct { p, q Point3D }

one may write

origin := Point3D{}                            // zero value for Point3D
line := Line{origin, Point3D{y: -4, z: 12.3}}  // zero value for line.q.x

For array and slice literals the following rules apply:

  * Each element has an associated integer index marking its position in the array.
  * An element with a key uses the key as its index; the key must be a constant integer expression.
  * An element without a key uses the previous element's index plus one. If the first element has
    no key, its index is zero.

Taking the address of a composite literal (§Address operators) generates a pointer to a unique
instance of the literal's value.

var pointer *Point3D = &Point3D{y: 1000}

The length of an array literal is the length specified in the LiteralType. If fewer elements than
the length are provided in the literal, the missing elements are set to the zero value for the
array element type. It is an error to provide elements with index values outside the index range of
the array. The notation ... specifies an array length equal to the maximum element index plus one.

buffer := [10]string{}               // len(buffer) == 10
intSet := [6]int{1, 2, 3, 5}         // len(intSet) == 6
days := [...]string{"Sat", "Sun"}    // len(days) == 2

A slice literal describes the entire underlying array literal. Thus, the length and capacity of a
slice literal are the maximum element index plus one. A slice literal has the form

[]T{x1, x2, ... xn}

and is a shortcut for a slice operation applied to an array literal:

[n]T{x1, x2, ... xn}[0 : n]

Within a composite literal of array, slice, or map type T, elements that are themselves composite
literals may elide the respective literal type if it is identical to the element type of T.

[...]Point{{1.5, -3.5}, {0, 0}}  // same as [...]Point{Point{1.5, -3.5}, Point{0, 0}}
[][]int{{1, 2, 3}, {4, 5}}       // same as [][]int{[]int{1, 2, 3}, []int{4, 5}}

A parsing ambiguity arises when a composite literal using the TypeName form of the LiteralType
appears between the keyword and the opening brace of the block of an "if", "for", or "switch"
statement, because the braces surrounding the expressions in the literal are confused with those
introducing the block of statements. To resolve the ambiguity in this rare case, the composite
literal must appear within parentheses.

if x == (T{a,b,c}[i]) { ... }
if (x == T{a,b,c}[i]) { ... }

Examples of valid array, slice, and map literals:

// list of prime numbers
primes := []int{2, 3, 5, 7, 9, 11, 13, 17, 19, 991}

// vowels[ch] is true if ch is a vowel
vowels := [128]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true, 'y': true}

// the array [10]float32{-1, 0, 0, 0, -0.1, -0.1, 0, 0, 0, -1}
filter := [10]float32{-1, 4: -0.1, -0.1, 9: -1}

// frequencies in Hz for equal-tempered scale (A4 = 440Hz)
noteFrequency := map[string]float32{
    "C0": 16.35, "D0": 18.35, "E0": 20.60, "F0": 21.83,
    "G0": 24.50, "A0": 27.50, "B0": 30.87,
}

Function literals

A function literal represents an anonymous function. It consists of a specification of the function
type and a function body.

FunctionLit = FunctionType Body .

func(a, b int, z float64) bool { return a*b < int(z) }

A function literal can be assigned to a variable or invoked directly.

f := func(x, y int) int { return x + y }
func(ch chan int) { ch <- ACK } (reply_chan)

Function literals are closures: they may refer to variables defined in a surrounding function.
Those variables are then shared between the surrounding function and the function literal, and they
survive as long as they are accessible.

Primary expressions

Primary expressions are the operands for unary and binary expressions.

PrimaryExpr =
    Operand |
    Conversion |
    BuiltinCall |
    PrimaryExpr Selector |
    PrimaryExpr Index |
    PrimaryExpr Slice |
    PrimaryExpr TypeAssertion |
    PrimaryExpr Call .

Selector       = "." identifier .
Index          = "[" Expression "]" .
Slice          = "[" [ Expression ] ":" [ Expression ] "]" .
TypeAssertion  = "." "(" Type ")" .
Call           = "(" [ ArgumentList [ "," ] ] ")" .
ArgumentList   = ExpressionList [ "..." ] .

x
2
(s + ".txt")
f(3.1415, true)
Point{1, 2}
m["foo"]
s[i : j + 1]
obj.color
math.Sin
f.p[i].x()

Selectors

A primary expression of the form

x.f

denotes the field or method f of the value denoted by x (or sometimes *x; see below). The
identifier f is called the (field or method) selector; it must not be the blank identifier. The
type of the expression is the type of f.

A selector f may denote a field or method f of a type T, or it may refer to a field or method f of
a nested anonymous field of T. The number of anonymous fields traversed to reach f is called its
depth in T. The depth of a field or method f declared in T is zero. The depth of a field or method
f declared in an anonymous field A in T is the depth of f in A plus one.

The following rules apply to selectors:

 1. For a value x of type T or *T where T is not an interface type, x.f denotes the field or method
    at the shallowest depth in T where there is such an f. If there is not exactly one f with
    shallowest depth, the selector expression is illegal.
 2. For a variable x of type I where I is an interface type, x.f denotes the actual method with
    name f of the value assigned to x if there is such a method. If no value or nil was assigned to
    x, x.f is illegal.
 3. In all other cases, x.f is illegal.

Selectors automatically dereference pointers to structs. If x is a pointer to a struct, x.y is
shorthand for (*x).y; if the field y is also a pointer to a struct, x.y.z is shorthand for (*
(*x).y).z, and so on. If x contains an anonymous field of type *A, where A is also a struct type,
x.f is a shortcut for (*x.A).f.

For example, given the declarations:

type T0 struct {
    x int
}

func (recv *T0) M0()

type T1 struct {
    y int
}

func (recv T1) M1()

type T2 struct {
    z int
    T1
    *T0
}

func (recv *T2) M2()

var p *T2  // with p != nil and p.T1 != nil

one may write:

p.z         // (*p).z
p.y         // ((*p).T1).y
p.x         // (*(*p).T0).x

p.M2        // (*p).M2
p.M1        // ((*p).T1).M1
p.M0        // ((*p).T0).M0

Indexes

A primary expression of the form

a[x]

denotes the element of the array, slice, string or map a indexed by x. The value x is called the
index or map key, respectively. The following rules apply:

For a of type A or *A where A is an array type, or for a of type S where S is a slice type:

  * x must be an integer value and 0 <= x < len(a)
  * a[x] is the array element at index x and the type of a[x] is the element type of A
  * if a is nil or if the index x is out of range, a run-time panic occurs

For a of type T where T is a string type:

  * x must be an integer value and 0 <= x < len(a)
  * a[x] is the byte at index x and the type of a[x] is byte
  * a[x] may not be assigned to
  * if the index x is out of range, a run-time panic occurs

For a of type M where M is a map type:

  * x's type must be assignable to the key type of M
  * if the map contains an entry with key x, a[x] is the map value with key x and the type of a[x]
    is the value type of M
  * if the map is nil or does not contain such an entry, a[x] is the zero value for the value type
    of M

Otherwise a[x] is illegal.

An index expression on a map a of type map[K]V may be used in an assignment or initialization of
the special form

v, ok = a[x]
v, ok := a[x]
var v, ok = a[x]

where the result of the index expression is a pair of values with types (V, bool). In this form,
the value of ok is true if the key x is present in the map, and false otherwise. The value of v is
the value a[x] as in the single-result form.

Similarly, if an assignment to a map element has the special form

a[x] = v, ok

and boolean ok has the value false, the entry for key x is deleted from the map; if ok is true, the
construct acts like a regular assignment to an element of the map.

Assigning to an element of a nil map causes a run-time panic.

Slices

For a string, array, or slice a, the primary expression

a[low : high]

constructs a substring or slice. The index expressions low and high select which elements appear in
the result. The result has indexes starting at 0 and length equal to high - low. After slicing the
array a

a := [5]int{1, 2, 3, 4, 5}
s := a[1:4]

the slice s has type []int, length 3, capacity 4, and elements

s[0] == 2
s[1] == 3
s[2] == 4

For convenience, any of the index expressions may be omitted. A missing low index defaults to zero;
a missing high index defaults to the length of the sliced operand:

a[2:]   // same a[2 : len(a)]
a[:3]   // same as a[0 : 3]
a[:]    // same as a[0 : len(a)]

For arrays or strings, the indexes low and high must satisfy 0 <= low <= high <= length; for
slices, the upper bound is the capacity rather than the length.

If the sliced operand is a string or slice, the result of the slice operation is a string or slice
of the same type. If the sliced operand is an array, it must be addressable and the result of the
slice operation is a slice with the same element type as the array.

Type assertions

For an expression x of interface type and a type T, the primary expression

x.(T)

asserts that x is not nil and that the value stored in x is of type T. The notation x.(T) is called
a type assertion.

More precisely, if T is not an interface type, x.(T) asserts that the dynamic type of x is
identical to the type T. If T is an interface type, x.(T) asserts that the dynamic type of x
implements the interface T (§Interface types).

If the type assertion holds, the value of the expression is the value stored in x and its type is
T. If the type assertion is false, a run-time panic occurs. In other words, even though the dynamic
type of x is known only at run-time, the type of x.(T) is known to be T in a correct program.

If a type assertion is used in an assignment or initialization of the form

v, ok = x.(T)
v, ok := x.(T)
var v, ok = x.(T)

the result of the assertion is a pair of values with types (T, bool). If the assertion holds, the
expression returns the pair (x.(T), true); otherwise, the expression returns (Z, false) where Z is
the zero value for type T. No run-time panic occurs in this case. The type assertion in this
construct thus acts like a function call returning a value and a boolean indicating success. (§
Assignments)

Calls

Given an expression f of function type F,

f(a1, a2, ... an)

calls f with arguments a1, a2, ... an. Except for one special case, arguments must be single-valued
expressions assignable to the parameter types of F and are evaluated before the function is called.
The type of the expression is the result type of F. A method invocation is similar but the method
itself is specified as a selector upon a value of the receiver type for the method.

math.Atan2(x, y)    // function call
var pt *Point
pt.Scale(3.5)  // method call with receiver pt

As a special case, if the return parameters of a function or method g are equal in number and
individually assignable to the parameters of another function or method f, then the call f(g(
parameters_of_g)) will invoke f after binding the return values of g to the parameters of f in
order. The call of f must contain no parameters other than the call of g. If f has a final ...
parameter, it is assigned the return values of g that remain after assignment of regular
parameters.

func Split(s string, pos int) (string, string) {
    return s[0:pos], s[pos:]
}

func Join(s, t string) string {
    return s + t
}

if Join(Split(value, len(value)/2)) != value {
    log.Panic("test fails")
}

A method call x.m() is valid if the method set of (the type of) x contains m and the argument list
can be assigned to the parameter list of m. If x is addressable and &x's method set contains m, x.m
() is shorthand for (&x).m():

var p Point
p.Scale(3.5)

There is no distinct method type and there are no method literals.

Passing arguments to ... parameters

If f is variadic with final parameter type ...T, then within the function the argument is
equivalent to a parameter of type []T. At each call of f, the argument passed to the final
parameter is a new slice of type []T whose successive elements are the actual arguments, which all
must be assignable to the type T. The length of the slice is therefore the number of arguments
bound to the final parameter and may differ for each call site.

Given the function and call

func Greeting(prefix string, who ...string)
Greeting("hello:", "Joe", "Anna", "Eileen")

within Greeting, who will have the value []string{"Joe", "Anna", "Eileen"}

If the final argument is assignable to a slice type []T, it may be passed unchanged as the value
for a ...T parameter if the argument is followed by .... In this case no new slice is created.

Given the slice s and call

s := []string{"James", "Jasmine"}
Greeting("goodbye:", s...)

within Greeting, who will have the same value as s with the same underlying array.

Operators

Operators combine operands into expressions.

Expression = UnaryExpr | Expression binary_op UnaryExpr .
UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .

binary_op  = "||" | "&&" | rel_op | add_op | mul_op .
rel_op     = "==" | "!=" | "<" | "<=" | ">" | ">=" .
add_op     = "+" | "-" | "|" | "^" .
mul_op     = "*" | "/" | "%" | "<<" | ">>" | "&" | "&^" .

unary_op   = "+" | "-" | "!" | "^" | "*" | "&" | "<-" .

Comparisons are discussed elsewhere. For other binary operators, the operand types must be
identical unless the operation involves shifts or untyped constants. For operations involving
constants only, see the section on constant expressions.

Except for shift operations, if one operand is an untyped constant and the other operand is not,
the constant is converted to the type of the other operand.

The right operand in a shift expression must have unsigned integer type or be an untyped constant
that can be converted to unsigned integer type. If the left operand of a non-constant shift
expression is an untyped constant, the type of the constant is what it would be if the shift
expression were replaced by its left operand alone; the type is int if it cannot be determined from
the context (for instance, if the shift expression is an operand in a comparison against an untyped
constant).

var s uint = 33
var i = 1<<s           // 1 has type int
var j int32 = 1<<s     // 1 has type int32; j == 0
var k = uint64(1<<s)   // 1 has type uint64; k == 1<<33
var m int = 1.0<<s     // legal: 1.0 has type int
var n = 1.0<<s != 0    // legal: 1.0 has type int; n == false if ints are 32bits in size
var o = 1<<s == 2<<s   // legal: 1 and 2 have type int; o == true if ints are 32bits in size
var p = 1<<s == 1<<33  // illegal if ints are 32bits in size: 1 has type int, but 1<<33 overflows int
var u = 1.0<<s         // illegal: 1.0 has type float64, cannot shift
var v float32 = 1<<s   // illegal: 1 has type float32, cannot shift
var w int64 = 1.0<<33  // legal: 1.0<<33 is a constant shift expression

Operator precedence

Unary operators have the highest precedence. As the ++ and -- operators form statements, not
expressions, they fall outside the operator hierarchy. As a consequence, statement *p++ is the same
as (*p)++.

There are five precedence levels for binary operators. Multiplication operators bind strongest,
followed by addition operators, comparison operators, && (logical and), and finally || (logical
or):

Precedence    Operator
    5             *  /  %  <<  >>  &  &^
    4             +  -  |  ^
    3             ==  !=  <  <=  >  >=
    2             &&
    1             ||

Binary operators of the same precedence associate from left to right. For instance, x / y * z is
the same as (x / y) * z.

+x
23 + 3*x[i]
x <= f()
^a >> b
f() || g()
x == y+1 && <-chan_ptr > 0

Arithmetic operators

Arithmetic operators apply to numeric values and yield a result of the same type as the first
operand. The four standard arithmetic operators (+, -, *, /) apply to integer, floating-point, and
complex types; + also applies to strings. All other arithmetic operators apply to integers only.

+    sum                    integers, floats, complex values, strings
-    difference             integers, floats, complex values
#    product                integers, floats, complex values
/    quotient               integers, floats, complex values
%    remainder              integers

&    bitwise and            integers
|    bitwise or             integers
^    bitwise xor            integers
&^   bit clear (and not)    integers

<<   left shift             integer << unsigned integer
>>   right shift            integer >> unsigned integer

Strings can be concatenated using the + operator or the += assignment operator:

s := "hi" + string(c)
s += " and good bye"

String addition creates a new string by concatenating the operands.

For two integer values x and y, the integer quotient q = x / y and remainder r = x % y satisfy the
following relationships:

x = q*y + r  and  |r| < |y|

with x / y truncated towards zero ("truncated division").

 x     y     x / y     x % y
 5     3       1         2
-5     3      -1        -2
 5    -3      -1         2
-5    -3       1        -2

As an exception to this rule, if the dividend x is the most negative value for the int type of x,
the quotient q = x / -1 is equal to x (and r = 0).

             x, q
int8                     -128
int16                  -32768
int32             -2147483648
int64    -9223372036854775808

If the divisor is zero, a run-time panic occurs. If the dividend is positive and the divisor is a
constant power of 2, the division may be replaced by a right shift, and computing the remainder may
be replaced by a bitwise "and" operation:

 x     x / 4     x % 4     x >> 2     x & 3
 11      2         3         2          3
-11     -2        -3        -3          1

The shift operators shift the left operand by the shift count specified by the right operand. They
implement arithmetic shifts if the left operand is a signed integer and logical shifts if it is an
unsigned integer. There is no upper limit on the shift count. Shifts behave as if the left operand
is shifted n times by 1 for a shift count of n. As a result, x << 1 is the same as x*2 and x >> 1
is the same as x/2 but truncated towards negative infinity.

For integer operands, the unary operators +, -, and ^ are defined as follows:

+x                          is 0 + x
-x    negation              is 0 - x
^x    bitwise complement    is m ^ x  with m = "all bits set to 1" for unsigned x
                                      and  m = -1 for signed x

For floating-point numbers, +x is the same as x, while -x is the negation of x. The result of a
floating-point division by zero is not specified beyond the IEEE-754 standard; whether a run-time
panic occurs is implementation-specific.

Integer overflow

For unsigned integer values, the operations +, -, *, and << are computed modulo 2^n, where n is the
bit width of the unsigned integer's type (§Numeric types). Loosely speaking, these unsigned integer
operations discard high bits upon overflow, and programs may rely on ``wrap around''.

For signed integers, the operations +, -, *, and << may legally overflow and the resulting value
exists and is deterministically defined by the signed integer representation, the operation, and
its operands. No exception is raised as a result of overflow. A compiler may not optimize code
under the assumption that overflow does not occur. For instance, it may not assume that x < x + 1
is always true.

Comparison operators

Comparison operators compare two operands and yield a value of type bool.

==    equal
!=    not equal
<     less
<=    less or equal
>     greater
>=    greater or equal

The operands must be comparable; that is, the first operand must be assignable to the type of the
second operand, or vice versa.

The operators == and != apply to operands of all types except arrays and structs. All other
comparison operators apply only to integer, floating-point and string values. The result of a
comparison is defined as follows:

  * Integer values are compared in the usual way.
  * Floating point values are compared as defined by the IEEE-754 standard.
  * Two complex values u, v are equal if both real(u) == real(v) and imag(u) == imag(v).
  * String values are compared byte-wise (lexically).
  * Boolean values are equal if they are either both true or both false.
  * Pointer values are equal if they point to the same location or if both are nil.
  * Function values are equal if they refer to the same function or if both are nil.
  * A slice value may only be compared to nil.
  * Channel and map values are equal if they were created by the same call to make (§Making slices,
    maps, and channels) or if both are nil.
  * Interface values are equal if they have identical dynamic types and equal dynamic values or if
    both are nil.
  * An interface value x is equal to a non-interface value y if the dynamic type of x is identical
    to the static type of y and the dynamic value of x is equal to y.
  * A pointer, function, slice, channel, map, or interface value is equal to nil if it has been
    assigned the explicit value nil, if it is uninitialized, or if it has been assigned another
    value equal to nil.

Logical operators

Logical operators apply to boolean values and yield a result of the same type as the operands. The
right operand is evaluated conditionally.

&&    conditional and    p && q  is  "if p then q else false"
||    conditional or     p || q  is  "if p then true else q"
!     not                !p      is  "not p"

Address operators

For an operand x of type T, the address operation &x generates a pointer of type *T to x. The
operand must be addressable, that is, either a variable, pointer indirection, or slice indexing
operation; or a field selector of an addressable struct operand; or an array indexing operation of
an addressable array. As an exception to the addressability requirement, x may also be a composite
literal.

For an operand x of pointer type *T, the pointer indirection *x denotes the value of type T pointed
to by x.

&x
&a[f(2)]
*p
*pf(x)
Receive operator

For an operand ch of channel type, the value of the receive operation <-ch is the value received
from the channel ch. The type of the value is the element type of the channel. The expression
blocks until a value is available. Receiving from a nil channel blocks forever.

v1 := <-ch
v2 = <-ch
f(<-ch)
<-strobe  // wait until clock pulse and discard received value

A receive expression used in an assignment or initialization of the form

x, ok = <-ch
x, ok := <-ch
var x, ok = <-ch

yields an additional result. The boolean variable ok indicates whether the received value was sent
on the channel (true) or is a zero value returned because the channel is closed and empty (false).

Method expressions

If M is in the method set of type T, T.M is a function that is callable as a regular function with
the same arguments as M prefixed by an additional argument that is the receiver of the method.

MethodExpr    = ReceiverType "." MethodName .
ReceiverType  = TypeName | "(" "*" TypeName ")" .

Consider a struct type T with two methods, Mv, whose receiver is of type T, and Mp, whose receiver
is of type *T.

type T struct {
    a int
}
func (tv  T) Mv(a int)     int     { return 0 }  // value receiver
func (tp *T) Mp(f float32) float32 { return 1 }  // pointer receiver
var t T

The expression

T.Mv

yields a function equivalent to Mv but with an explicit receiver as its first argument; it has
signature

func(tv T, a int) int

That function may be called normally with an explicit receiver, so these three invocations are
equivalent:

t.Mv(7)
T.Mv(t, 7)
f := T.Mv; f(t, 7)

Similarly, the expression

(*T).Mp

yields a function value representing Mp with signature

func(tp *T, f float32) float32

For a method with a value receiver, one can derive a function with an explicit pointer receiver, so

(*T).Mv

yields a function value representing Mv with signature

func(tv *T, a int) int

Such a function indirects through the receiver to create a value to pass as the receiver to the
underlying method; the method does not overwrite the value whose address is passed in the function
call.

The final case, a value-receiver function for a pointer-receiver method, is illegal because
pointer-receiver methods are not in the method set of the value type.

Function values derived from methods are called with function call syntax; the receiver is provided
as the first argument to the call. That is, given f := T.Mv, f is invoked as f(t, 7) not t.f(7). To
construct a function that binds the receiver, use a closure.

It is legal to derive a function value from a method of an interface type. The resulting function
takes an explicit receiver of that interface type.

Conversions

Conversions are expressions of the form T(x) where T is a type and x is an expression that can be
converted to type T.

Conversion = Type "(" Expression ")" .

If the type starts with an operator it must be parenthesized:
*Point(p)        // same as *(Point(p))
(*Point)(p)      // p is converted to (*Point)
<-chan int(c)    // same as <-(chan int(c))
(<-chan int)(c)  // c is converted to (<-chan int)

A constant value x can be converted to type T in any of these cases:

  * x is representable by a value of type T.
  * x is an integer constant and T is a string type. The same rule as for non-constant x applies in
    this case (§Conversions to and from a string type).

Converting a constant yields a typed constant as result.

uint(iota)               // iota value of type uint
float32(2.718281828)     // 2.718281828 of type float32
complex128(1)            // 1.0 + 0.0i of type complex128
string('x')              // "x" of type string
string(0x266c)           // "♬" of type string
MyString("foo" + "bar")  // "foobar" of type MyString
string([]byte{'a'})      // not a constant: []byte{'a'} is not a constant
(*int)(nil)              // not a constant: nil is not a constant, *int is not a boolean, numeric, or string type
int(1.2)                 // illegal: 1.2 cannot be represented as an int
string(65.0)             // illegal: 65.0 is not an integer constant

A non-constant value x can be converted to type T in any of these cases:

  * x is assignable to T.
  * x's type and T have identical underlying types.
  * x's type and T are unnamed pointer types and their pointer base types have identical underlying
    types.
  * x's type and T are both integer or floating point types.
  * x's type and T are both complex types.
  * x is an integer or has type []byte or []int and T is a string type.
  * x is a string and T is []byte or []int.

Specific rules apply to (non-constant) conversions between numeric types or to and from a string
type. These conversions may change the representation of x and incur a run-time cost. All other
conversions only change the type but not the representation of x.

There is no linguistic mechanism to convert between pointers and integers. The package unsafe
implements this functionality under restricted circumstances.

Conversions between numeric types

For the conversion of non-constant numeric values, the following rules apply:

 1. When converting between integer types, if the value is a signed integer, it is sign extended to
    implicit infinite precision; otherwise it is zero extended. It is then truncated to fit in the
    result type's size. For example, if v := uint16(0x10F0), then uint32(int8(v)) == 0xFFFFFFF0.
    The conversion always yields a valid value; there is no indication of overflow.
 2. When converting a floating-point number to an integer, the fraction is discarded (truncation
    towards zero).
 3. When converting an integer or floating-point number to a floating-point type, or a complex
    number to another complex type, the result value is rounded to the precision specified by the
    destination type. For instance, the value of a variable x of type float32 may be stored using
    additional precision beyond that of an IEEE-754 32-bit number, but float32(x) represents the
    result of rounding x's value to 32-bit precision. Similarly, x + 0.1 may use more than 32 bits
    of precision, but float32(x + 0.1) does not.

In all non-constant conversions involving floating-point or complex values, if the result type
cannot represent the value the conversion succeeds but the result value is
implementation-dependent.

Conversions to and from a string type

 1. Converting a signed or unsigned integer value to a string type yields a string containing the
    UTF-8 representation of the integer. Values outside the range of valid Unicode code points are
    converted to "\uFFFD".

    string('a')           // "a"
    string(-1)            // "\ufffd" == "\xef\xbf\xbd "
    string(0xf8)          // "\u00f8" == "ø" == "\xc3\xb8"
    type MyString string
    MyString(0x65e5)      // "\u65e5" == "日" == "\xe6\x97\xa5"

 2. Converting a value of type []byte (or the equivalent []uint8) to a string type yields a string
    whose successive bytes are the elements of the slice. If the slice value is nil, the result is
    the empty string.

    string([]byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'})  // "hellø"

 3. Converting a value of type []int to a string type yields a string that is the concatenation of
    the individual integers converted to strings. If the slice value is nil, the result is the
    empty string.

    string([]int{0x767d, 0x9d6c, 0x7fd4})  // "\u767d\u9d6c\u7fd4" == "白鵬翔"

 4. Converting a value of a string type to []byte (or []uint8) yields a slice whose successive
    elements are the bytes of the string. If the string is empty, the result is []byte(nil).

    []byte("hellø")  // []byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'}

 5. Converting a value of a string type to []int yields a slice containing the individual Unicode
    code points of the string. If the string is empty, the result is []int(nil).

    []int(MyString("白鵬翔"))  // []int{0x767d, 0x9d6c, 0x7fd4}

Constant expressions

Constant expressions may contain only constant operands and are evaluated at compile-time.

Untyped boolean, numeric, and string constants may be used as operands wherever it is legal to use
an operand of boolean, numeric, or string type, respectively. Except for shift operations, if the
operands of a binary operation are an untyped integer constant and an untyped floating-point
constant, the integer constant is converted to an untyped floating-point constant (relevant for /
and %). Similarly, untyped integer or floating-point constants may be used as operands wherever it
is legal to use an operand of complex type; the integer or floating point constant is converted to
a complex constant with a zero imaginary part.

A constant comparison always yields a constant of type bool. If the left operand of a constant
shift expression is an untyped constant, the result is an integer constant; otherwise it is a
constant of the same type as the left operand, which must be of integer type (§Arithmetic operators
). Applying all other operators to untyped constants results in an untyped constant of the same
kind (that is, a boolean, integer, floating-point, complex, or string constant).

const a = 2 + 3.0          // a == 5.0   (floating-point constant)
const b = 15 / 4           // b == 3     (integer constant)
const c = 15 / 4.0         // c == 3.75  (floating-point constant)
const d = 1 << 3.0         // d == 8     (integer constant)
const e = 1.0 << 3         // e == 8     (integer constant)
const f = int32(1) << 33   // f == 0     (type int32)
const g = float64(2) >> 1  // illegal    (float64(2) is a typed floating-point constant)
const h = "foo" > "bar"    // h == true  (type bool)

Imaginary literals are untyped complex constants (with zero real part) and may be combined in
binary operations with untyped integer and floating-point constants; the result is an untyped
complex constant. Complex constants are always constructed from constant expressions involving
imaginary literals or constants derived from them, or calls of the built-in function complex.

const Σ = 1 - 0.707i
const Δ = Σ + 2.0e-4 - 1/1i
const Φ = iota * 1i
const iΓ = complex(0, Γ)

Constant expressions are always evaluated exactly; intermediate values and the constants themselves
may require precision significantly larger than supported by any predeclared type in the language.
The following are legal declarations:

const Huge = 1 << 100
const Four int8 = Huge >> 98

The values of typed constants must always be accurately representable as values of the constant
type. The following constant expressions are illegal:

uint(-1)       // -1 cannot be represented as a uint
int(3.14)      // 3.14 cannot be represented as an int
int64(Huge)    // 1<<100 cannot be represented as an int64
Four * 300     // 300 cannot be represented as an int8
Four * 100     // 400 cannot be represented as an int8

The mask used by the unary bitwise complement operator ^ matches the rule for non-constants: the
mask is all 1s for unsigned constants and -1 for signed and untyped constants.

^1          // untyped integer constant, equal to -2
uint8(^1)   // error, same as uint8(-2), out of range
^uint8(1)   // typed uint8 constant, same as 0xFF ^ uint8(1) = uint8(0xFE)
int8(^1)    // same as int8(-2)
^int8(1)    // same as -1 ^ int8(1) = -2

Order of evaluation

When evaluating the elements of an assignment or expression, all function calls, method calls and
communication operations are evaluated in lexical left-to-right order.

For example, in the assignment

y[f()], ok = g(h(), i() + x[j()], <-c), k()

the function calls and communication happen in the order f(), h(), i(), j(), <-c, g(), and k().
However, the order of those events compared to the evaluation and indexing of x and the evaluation
of y is not specified.

Floating-point operations within a single expression are evaluated according to the associativity
of the operators. Explicit parentheses affect the evaluation by overriding the default
associativity. In the expression x + (y + z) the addition y + z is performed before adding x.

Statements

Statements control execution.

Statement =
    Declaration | LabeledStmt | SimpleStmt |
    GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
    FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
    DeferStmt .

SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .

Empty statements

The empty statement does nothing.

EmptyStmt = .

Labeled statements

A labeled statement may be the target of a goto, break or continue statement.

LabeledStmt = Label ":" Statement .
Label       = identifier .

Error: log.Panic("error encountered")

Expression statements

Function calls, method calls, and receive operations can appear in statement context. Such
statements may be parenthesized.

ExpressionStmt = Expression .

h(x+y)
f.Close()
<-ch
(<-ch)

Send statements

A send statement sends a value on a channel. The channel expression must be of channel type and the
type of the value must be assignable to the channel's element type.

SendStmt = Channel "<-" Expression .
Channel  = Expression .

Both the channel and the value expression are evaluated before communication begins. Communication
blocks until the send can proceed, at which point the value is transmitted on the channel. A send
on an unbuffered channel can proceed if a receiver is ready. A send on a buffered channel can
proceed if there is room in the buffer. A send on a nil channel blocks forever.

ch <- 3

IncDec statements

The "++" and "--" statements increment or decrement their operands by the untyped constant 1. As
with an assignment, the operand must be addressable or a map index expression.

IncDecStmt = Expression ( "++" | "--" ) .

The following assignment statements are semantically equivalent:

IncDec statement    Assignment
x++                 x += 1
x--                 x -= 1

Assignments

Assignment = ExpressionList assign_op ExpressionList .

assign_op = [ add_op | mul_op ] "=" .

Each left-hand side operand must be addressable, a map index expression, or the blank identifier.
Operands may be parenthesized.

x = 1
*p = f()
a[i] = 23
(k) = <-ch  // same as: k = <-ch

An assignment operation x op= y where op is a binary arithmetic operation is equivalent to x = x op
y but evaluates x only once. The op= construct is a single token. In assignment operations, both
the left- and right-hand expression lists must contain exactly one single-valued expression.

a[i] <<= 2
i &^= 1<<n

A tuple assignment assigns the individual elements of a multi-valued operation to a list of
variables. There are two forms. In the first, the right hand operand is a single multi-valued
expression such as a function evaluation or channel or map operation or a type assertion. The
number of operands on the left hand side must match the number of values. For instance, if f is a
function returning two values,

x, y = f()

assigns the first value to x and the second to y. The blank identifier provides a way to ignore
values returned by a multi-valued expression:

x, _ = f()  // ignore second value returned by f()

In the second form, the number of operands on the left must equal the number of expressions on the
right, each of which must be single-valued, and the nth expression on the right is assigned to the
nth operand on the left. The expressions on the right are evaluated before assigning to any of the
operands on the left, but otherwise the evaluation order is unspecified beyond the usual rules.

a, b = b, a  // exchange a and b

In assignments, each value must be assignable to the type of the operand to which it is assigned.
If an untyped constant is assigned to a variable of interface type, the constant is converted to
type bool, int, float64, complex128 or string respectively, depending on whether the value is a
boolean, integer, floating-point, complex, or string constant.

If statements

"If" statements specify the conditional execution of two branches according to the value of a
boolean expression. If the expression evaluates to true, the "if" branch is executed, otherwise, if
present, the "else" branch is executed.

IfStmt = "if" [ SimpleStmt ";" ] Expression Block [ "else" ( IfStmt | Block ) ] .

if x > max {
    x = max
}

The expression may be preceded by a simple statement, which executes before the expression is
evaluated.

if x := f(); x < y {
    return x
} else if x > z {
    return z
} else {
    return y
}

Switch statements

"Switch" statements provide multi-way execution. An expression or type specifier is compared to the
"cases" inside the "switch" to determine which branch to execute.

SwitchStmt = ExprSwitchStmt | TypeSwitchStmt .

There are two forms: expression switches and type switches. In an expression switch, the cases
contain expressions that are compared against the value of the switch expression. In a type switch,
the cases contain types that are compared against the type of a specially annotated switch
expression.

Expression switches

In an expression switch, the switch expression is evaluated and the case expressions, which need
not be constants, are evaluated left-to-right and top-to-bottom; the first one that equals the
switch expression triggers execution of the statements of the associated case; the other cases are
skipped. If no case matches and there is a "default" case, its statements are executed. There can
be at most one default case and it may appear anywhere in the "switch" statement. A missing switch
expression is equivalent to the expression true.

ExprSwitchStmt = "switch" [ SimpleStmt ";" ] [ Expression ] "{" { ExprCaseClause } "}" .
ExprCaseClause = ExprSwitchCase ":" { Statement ";" } .
ExprSwitchCase = "case" ExpressionList | "default" .

In a case or default clause, the last statement only may be a "fallthrough" statement (§Fallthrough
statement) to indicate that control should flow from the end of this clause to the first statement
of the next clause. Otherwise control flows to the end of the "switch" statement.

The expression may be preceded by a simple statement, which executes before the expression is
evaluated.

switch tag {
default: s3()
case 0, 1, 2, 3: s1()
case 4, 5, 6, 7: s2()
}

switch x := f(); {  // missing switch expression means "true"
case x < 0: return -x
default: return x
}

switch {
case x < y: f1()
case x < z: f2()
case x == 4: f3()
}

Type switches

A type switch compares types rather than values. It is otherwise similar to an expression switch.
It is marked by a special switch expression that has the form of a type assertion using the
reserved word type rather than an actual type. Cases then match literal types against the dynamic
type of the expression in the type assertion.

TypeSwitchStmt  = "switch" [ SimpleStmt ";" ] TypeSwitchGuard "{" { TypeCaseClause } "}" .
TypeSwitchGuard = [ identifier ":=" ] PrimaryExpr "." "(" "type" ")" .
TypeCaseClause  = TypeSwitchCase ":" { Statement ";" } .
TypeSwitchCase  = "case" TypeList | "default" .
TypeList        = Type { "," Type } .

The TypeSwitchGuard may include a short variable declaration. When that form is used, the variable
is declared in each clause. In clauses with a case listing exactly one type, the variable has that
type; otherwise, the variable has the type of the expression in the TypeSwitchGuard.

The type in a case may be nil (§Predeclared identifiers); that case is used when the expression in
the TypeSwitchGuard is a nil interface value.

Given an expression x of type interface{}, the following type switch:

switch i := x.(type) {
case nil:
    printString("x is nil")
case int:
    printInt(i)  // i is an int
case float64:
    printFloat64(i)  // i is a float64
case func(int) float64:
    printFunction(i)  // i is a function
case bool, string:
    printString("type is bool or string")  // i is an interface{}
default:
    printString("don't know the type")
}

could be rewritten:

v := x  // x is evaluated exactly once
if v == nil {
    printString("x is nil")
} else if i, is_int := v.(int); is_int {
    printInt(i)  // i is an int
} else if i, is_float64 := v.(float64); is_float64 {
    printFloat64(i)  // i is a float64
} else if i, is_func := v.(func(int) float64); is_func {
    printFunction(i)  // i is a function
} else {
    i1, is_bool := v.(bool)
    i2, is_string := v.(string)
    if is_bool || is_string {
        i := v
        printString("type is bool or string")  // i is an interface{}
    } else {
        i := v
        printString("don't know the type")  // i is an interface{}
    }
}

The type switch guard may be preceded by a simple statement, which executes before the guard is
evaluated.

The "fallthrough" statement is not permitted in a type switch.

For statements

A "for" statement specifies repeated execution of a block. The iteration is controlled by a
condition, a "for" clause, or a "range" clause.

ForStmt = "for" [ Condition | ForClause | RangeClause ] Block .
Condition = Expression .

In its simplest form, a "for" statement specifies the repeated execution of a block as long as a
boolean condition evaluates to true. The condition is evaluated before each iteration. If the
condition is absent, it is equivalent to true.

for a < b {
    a *= 2
}

A "for" statement with a ForClause is also controlled by its condition, but additionally it may
specify an init and a post statement, such as an assignment, an increment or decrement statement.
The init statement may be a short variable declaration, but the post statement must not.

ForClause = [ InitStmt ] ";" [ Condition ] ";" [ PostStmt ] .
InitStmt = SimpleStmt .
PostStmt = SimpleStmt .

for i := 0; i < 10; i++ {
    f(i)
}

If non-empty, the init statement is executed once before evaluating the condition for the first
iteration; the post statement is executed after each execution of the block (and only if the block
was executed). Any element of the ForClause may be empty but the semicolons are required unless
there is only a condition. If the condition is absent, it is equivalent to true.

for cond { S() }    is the same as    for ; cond ; { S() }
for      { S() }    is the same as    for true     { S() }

A "for" statement with a "range" clause iterates through all entries of an array, slice, string or
map, or values received on a channel. For each entry it assigns iteration values to corresponding
iteration variables and then executes the block.

RangeClause = Expression [ "," Expression ] ( "=" | ":=" ) "range" Expression .

The expression on the right in the "range" clause is called the range expression, which may be an
array, pointer to an array, slice, string, map, or channel. As with an assignment, the operands on
the left must be addressable or map index expressions; they denote the iteration variables. If the
range expression is a channel, only one iteration variable is permitted, otherwise there may be one
or two. If the second iteration variable is the blank identifier, the range clause is equivalent to
the same clause with only the first variable present.

The range expression is evaluated once before beginning the loop except if the expression is an
array, in which case, depending on the expression, it might not be evaluated (see below). Function
calls on the left are evaluated once per iteration. For each iteration, iteration values are
produced as follows:

Range expression                          1st value          2nd value (if 2nd variable is present)

array or slice  a  [n]E, *[n]E, or []E    index    i  int    a[i]       E
string          s  string type            index    i  int    see below  int
map             m  map[K]V                key      k  K      m[k]       V
channel         c  chan E                 element  e  E

 1. For an array, pointer to array, or slice value a, the index iteration values are produced in
    increasing order, starting at element index 0. As a special case, if only the first iteration
    variable is present, the range loop produces iteration values from 0 up to len(a) and does not
    index into the array or slice itself. For a nil slice, the number of iterations is 0.
 2. For a string value, the "range" clause iterates over the Unicode code points in the string
    starting at byte index 0. On successive iterations, the index value will be the index of the
    first byte of successive UTF-8-encoded code points in the string, and the second value, of type
    int, will be the value of the corresponding code point. If the iteration encounters an invalid
    UTF-8 sequence, the second value will be 0xFFFD, the Unicode replacement character, and the
    next iteration will advance a single byte in the string.
 3. The iteration order over maps is not specified. If map entries that have not yet been reached
    are deleted during iteration, the corresponding iteration values will not be produced. If map
    entries are inserted during iteration, the behavior is implementation-dependent, but the
    iteration values for each entry will be produced at most once. If the map is nil, the number of
    iterations is 0.
 4. For channels, the iteration values produced are the successive values sent on the channel until
    the channel is closed. If the channel is nil, the range expression blocks forever.

The iteration values are assigned to the respective iteration variables as in an assignment
statement.

The iteration variables may be declared by the "range" clause (:=). In this case their types are
set to the types of the respective iteration values and their scope ends at the end of the "for"
statement; they are re-used in each iteration. If the iteration variables are declared outside the
"for" statement, after execution their values will be those of the last iteration.

var testdata *struct {
    a *[7]int
}
for i, _ := range testdata.a {
    // testdata.a is never evaluated; len(testdata.a) is constant
    // i ranges from 0 to 6
    f(i)
}

var a [10]string
m := map[string]int{"mon":0, "tue":1, "wed":2, "thu":3, "fri":4, "sat":5, "sun":6}
for i, s := range a {
    // type of i is int
    // type of s is string
    // s == a[i]
    g(i, s)
}

var key string
var val interface {}  // value type of m is assignable to val
for key, val = range m {
    h(key, val)
}
// key == last map key encountered in iteration
// val == map[key]

var ch chan Work = producer()
for w := range ch {
    doWork(w)
}

Go statements

A "go" statement starts the execution of a function or method call as an independent concurrent
thread of control, or goroutine, within the same address space.

GoStmt = "go" Expression .

The expression must be a call, and unlike with a regular call, program execution does not wait for
the invoked function to complete.

go Server()
go func(ch chan<- bool) { for { sleep(10); ch <- true; }} (c)

Select statements

A "select" statement chooses which of a set of possible communications will proceed. It looks
similar to a "switch" statement but with the cases all referring to communication operations.

SelectStmt = "select" "{" { CommClause } "}" .
CommClause = CommCase ":" { Statement ";" } .
CommCase   = "case" ( SendStmt | RecvStmt ) | "default" .
RecvStmt   = [ Expression [ "," Expression ] ( "=" | ":=" ) ] RecvExpr .
RecvExpr   = Expression .

RecvExpr must be a receive operation. For all the cases in the "select" statement, the channel
expressions are evaluated in top-to-bottom order, along with any expressions that appear on the
right hand side of send statements. A channel may be nil, which is equivalent to that case not
being present in the select statement except, if a send, its expression is still evaluated. If any
of the resulting operations can proceed, one of those is chosen and the corresponding communication
and statements are evaluated. Otherwise, if there is a default case, that executes; if there is no
default case, the statement blocks until one of the communications can complete. If there are no
cases with non-nil channels, the statement blocks forever. Even if the statement blocks, the
channel and send expressions are evaluated only once, upon entering the select statement.

Since all the channels and send expressions are evaluated, any side effects in that evaluation will
occur for all the communications in the "select" statement.

If multiple cases can proceed, a pseudo-random fair choice is made to decide which single
communication will execute.

The receive case may declare one or two new variables using a short variable declaration.

var c, c1, c2, c3 chan int
var i1, i2 int
select {
case i1 = <-c1:
    print("received ", i1, " from c1\n")
case c2 <- i2:
    print("sent ", i2, " to c2\n")
case i3, ok := (<-c3):  // same as: i3, ok := <-c3
    if ok {
        print("received ", i3, " from c3\n")
    } else {
        print("c3 is closed\n")
    }
default:
    print("no communication\n")
}

for {  // send random sequence of bits to c
    select {
    case c <- 0:  // note: no statement, no fallthrough, no folding of cases
    case c <- 1:
    }
}

select { }  // block forever

Return statements

A "return" statement terminates execution of the containing function and optionally provides a
result value or values to the caller.

ReturnStmt = "return" [ ExpressionList ] .

In a function without a result type, a "return" statement must not specify any result values.

func no_result() {
    return
}

There are three ways to return values from a function with a result type:

 1. The return value or values may be explicitly listed in the "return" statement. Each expression
    must be single-valued and assignable to the corresponding element of the function's result
    type.

    func simple_f() int {
        return 2
    }

    func complex_f1() (re float64, im float64) {
        return -7.0, -4.0
    }

 2. The expression list in the "return" statement may be a single call to a multi-valued function.
    The effect is as if each value returned from that function were assigned to a temporary
    variable with the type of the respective value, followed by a "return" statement listing these
    variables, at which point the rules of the previous case apply.

    func complex_f2() (re float64, im float64) {
        return complex_f1()
    }

 3. The expression list may be empty if the function's result type specifies names for its result
    parameters (§Function Types). The result parameters act as ordinary local variables and the
    function may assign values to them as necessary. The "return" statement returns the values of
    these variables.

    func complex_f3() (re float64, im float64) {
        re = 7.0
        im = 4.0
        return
    }

    func (devnull) Write(p []byte) (n int, _ os.Error) {
        n = len(p)
        return
    }

Regardless of how they are declared, all the result values are initialized to the zero values for
their type (§The zero value) upon entry to the function.

Break statements

A "break" statement terminates execution of the innermost "for", "switch" or "select" statement.

BreakStmt = "break" [ Label ] .

If there is a label, it must be that of an enclosing "for", "switch" or "select" statement, and
that is the one whose execution terminates (§For statements, §Switch statements, §Select statements
).

L:
    for i < n {
        switch i {
        case 5:
            break L
        }
    }

Continue statements

A "continue" statement begins the next iteration of the innermost "for" loop at its post statement
(§For statements).

ContinueStmt = "continue" [ Label ] .

If there is a label, it must be that of an enclosing "for" statement, and that is the one whose
execution advances (§For statements).

Goto statements

A "goto" statement transfers control to the statement with the corresponding label.

GotoStmt = "goto" Label .

goto Error

Executing the "goto" statement must not cause any variables to come into scope that were not
already in scope at the point of the goto. For instance, this example:

    goto L  // BAD
    v := 3
L:

is erroneous because the jump to label L skips the creation of v.

A "goto" statement outside a block cannot jump to a label inside that block. For instance, this
example:

if n%2 == 1 {
    goto L1
}
for n > 0 {
    f()
    n--
L1:
    f()
    n--
}

is erroneous because the label L1 is inside the "for" statement's block but the goto is not.

Fallthrough statements

A "fallthrough" statement transfers control to the first statement of the next case clause in a
expression "switch" statement (§Expression switches). It may be used only as the final non-empty
statement in a case or default clause in an expression "switch" statement.

FallthroughStmt = "fallthrough" .

Defer statements

A "defer" statement invokes a function whose execution is deferred to the moment the surrounding
function returns.

DeferStmt = "defer" Expression .

The expression must be a function or method call. Each time the "defer" statement executes, the
parameters to the function call are evaluated and saved anew but the function is not invoked.
Deferred function calls are executed in LIFO order immediately before the surrounding function
returns, after the return values, if any, have been evaluated, but before they are returned to the
caller. For instance, if the deferred function is a function literal and the surrounding function
has named result parameters that are in scope within the literal, the deferred function may access
and modify the result parameters before they are returned.

lock(l)
defer unlock(l)  // unlocking happens before surrounding function returns

// prints 3 2 1 0 before surrounding function returns
for i := 0; i <= 3; i++ {
    defer fmt.Print(i)
}

// f returns 1
func f() (result int) {
    defer func() {
        result++
    }()
    return 0
}

Built-in functions

Built-in functions are predeclared. They are called like any other function but some of them accept
a type instead of an expression as the first argument.

The built-in functions do not have standard Go types, so they can only appear in call expressions;
they cannot be used as function values.

BuiltinCall = identifier "(" [ BuiltinArgs [ "," ] ] ")" .
BuiltinArgs = Type [ "," ExpressionList ] | ExpressionList .

Close

For a channel c, the built-in function close(c) marks the channel as unable to accept more values
through a send operation; sending to or closing a closed channel causes a run-time panic. After
calling close, and after any previously sent values have been received, receive operations will
return the zero value for the channel's type without blocking. The multi-valued receive operation
returns a received value along with an indication of whether the channel is closed.

Length and capacity

The built-in functions len and cap take arguments of various types and return a result of type int.
The implementation guarantees that the result always fits into an int.

Call      Argument type    Result

len(s)    string type      string length in bytes
          [n]T, *[n]T      array length (== n)
          []T              slice length
          map[K]T          map length (number of defined keys)
          chan T           number of elements queued in channel buffer

cap(s)    [n]T, *[n]T      array length (== n)
          []T              slice capacity
          chan T           channel buffer capacity

The capacity of a slice is the number of elements for which there is space allocated in the
underlying array. At any time the following relationship holds:

0 <= len(s) <= cap(s)

The length and capacity of a nil slice, map, or channel are 0.

The expression len(s) is constant if s is a string constant. The expressions len(s) and cap(s) are
constants if the type of s is an array or pointer to an array and the expression s does not contain
channel receives or function calls; in this case s is not evaluated. Otherwise, invocations of len
and cap are not constant and s is evaluated.

Allocation

The built-in function new takes a type T and returns a value of type *T. The memory is initialized
as described in the section on initial values (§The zero value).

new(T)

For instance

type S struct { a int; b float64 }
new(S)

dynamically allocates memory for a variable of type S, initializes it (a=0, b=0.0), and returns a
value of type *S containing the address of the memory.

Making slices, maps and channels

Slices, maps and channels are reference types that do not require the extra indirection of an
allocation with new. The built-in function make takes a type T, which must be a slice, map or
channel type, optionally followed by a type-specific list of expressions. It returns a value of
type T (not *T). The memory is initialized as described in the section on initial values (§The zero
value).

Call             Type T     Result

make(T, n)       slice      slice of type T with length n and capacity n
make(T, n, m)    slice      slice of type T with length n and capacity m

make(T)          map        map of type T
make(T, n)       map        map of type T with initial space for n elements

make(T)          channel    synchronous channel of type T
make(T, n)       channel    asynchronous channel of type T, buffer size n

The arguments n and m must be of integer type. A run-time panic occurs if n is negative or larger
than m, or if n or m cannot be represented by an int.

s := make([]int, 10, 100)        // slice with len(s) == 10, cap(s) == 100
s := make([]int, 10)             // slice with len(s) == cap(s) == 10
c := make(chan int, 10)          // channel with a buffer size of 10
m := make(map[string] int, 100)  // map with initial space for 100 elements

Appending to and copying slices

Two built-in functions assist in common slice operations.

The variadic function append appends zero or more values x to s of type S, which must be a slice
type, and returns the resulting slice, also of type S. The values x are passed to a parameter of
type ...T where T is the element type of S and the respective parameter passing rules apply.

append(s S, x ...T) S  // T is the element type of S

If the capacity of s is not large enough to fit the additional values, append allocates a new,
sufficiently large slice that fits both the existing slice elements and the additional values.
Thus, the returned slice may refer to a different underlying array.

s0 := []int{0, 0}
s1 := append(s0, 2)        // append a single element     s1 == []int{0, 0, 2}
s2 := append(s1, 3, 5, 7)  // append multiple elements    s2 == []int{0, 0, 2, 3, 5, 7}
s3 := append(s2, s0...)    // append a slice              s3 == []int{0, 0, 2, 3, 5, 7, 0, 0}

var t []interface{}
t = append(t, 42, 3.1415, "foo")                          t == []interface{}{42, 3.1415, "foo"}

The function copy copies slice elements from a source src to a destination dst and returns the
number of elements copied. Source and destination may overlap. Both arguments must have identical
element type T and must be assignable to a slice of type []T. The number of elements copied is the
minimum of len(src) and len(dst). As a special case, copy also accepts a destination argument
assignable to type []byte with a source argument of a string type. This form copies the bytes from
the string into the byte slice.

copy(dst, src []T) int
copy(dst []byte, src string) int

Examples:

var a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}
var s = make([]int, 6)
var b = make([]byte, 5)
n1 := copy(s, a[0:])            // n1 == 6, s == []int{0, 1, 2, 3, 4, 5}
n2 := copy(s, s[2:])            // n2 == 4, s == []int{2, 3, 4, 5, 4, 5}
n3 := copy(b, "Hello, World!")  // n3 == 5, b == []byte("Hello")

Assembling and disassembling complex numbers

Three functions assemble and disassemble complex numbers. The built-in function complex constructs
a complex value from a floating-point real and imaginary part, while real and imag extract the real
and imaginary parts of a complex value.

complex(realPart, imaginaryPart floatT) complexT
real(complexT) floatT
imag(complexT) floatT

The type of the arguments and return value correspond. For complex, the two arguments must be of
the same floating-point type and the return type is the complex type with the corresponding
floating-point constituents: complex64 for float32, complex128 for float64. The real and imag
functions together form the inverse, so for a complex value z, z == complex(real(z), imag(z)).

If the operands of these functions are all constants, the return value is a constant.

var a = complex(2, -2)             // complex128
var b = complex(1.0, -1.4)         // complex128
x := float32(math.Cos(math.Pi/2))  // float32
var c64 = complex(5, -x)           // complex64
var im = imag(b)                   // float64
var rl = real(c64)                 // float32

Handling panics

Two built-in functions, panic and recover, assist in reporting and handling run-time panics and
program-defined error conditions.

func panic(interface{})
func recover() interface{}

When a function F calls panic, normal execution of F stops immediately. Any functions whose
execution was deferred by the invocation of F are run in the usual way, and then F returns to its
caller. To the caller, F then behaves like a call to panic, terminating its own execution and
running deferred functions. This continues until all functions in the goroutine have ceased
execution, in reverse order. At that point, the program is terminated and the error condition is
reported, including the value of the argument to panic. This termination sequence is called
panicking.

panic(42)
panic("unreachable")
panic(Error("cannot parse"))

The recover function allows a program to manage behavior of a panicking goroutine. Executing a
recover call inside a deferred function (but not any function called by it) stops the panicking
sequence by restoring normal execution, and retrieves the error value passed to the call of panic.
If recover is called outside the deferred function it will not stop a panicking sequence. In this
case, or when the goroutine is not panicking, or if the argument supplied to panic was nil, recover
returns nil.

The protect function in the example below invokes the function argument g and protects callers from
run-time panics raised by g.

func protect(g func()) {
    defer func() {
        log.Println("done")  // Println executes normally even in there is a panic
        if x := recover(); x != nil {
            log.Printf("run time panic: %v", x)
        }
    }()
    log.Println("start")
    g()
}

Bootstrapping

Current implementations provide several built-in functions useful during bootstrapping. These
functions are documented for completeness but are not guaranteed to stay in the language. They do
not return a result.

Function   Behavior

print      prints all arguments; formatting of arguments is implementation-specific
println    like print but prints spaces between arguments and a newline at the end

Packages

Go programs are constructed by linking together packages. A package in turn is constructed from one
or more source files that together declare constants, types, variables and functions belonging to
the package and which are accessible in all files of the same package. Those elements may be
exported and used in another package.

Source file organization

Each source file consists of a package clause defining the package to which it belongs, followed by
a possibly empty set of import declarations that declare packages whose contents it wishes to use,
followed by a possibly empty set of declarations of functions, types, variables, and constants.

SourceFile       = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" } .

Package clause

A package clause begins each source file and defines the package to which the file belongs.

PackageClause  = "package" PackageName .
PackageName    = identifier .

The PackageName must not be the blank identifier.

package math

A set of files sharing the same PackageName form the implementation of a package. An implementation
may require that all source files for a package inhabit the same directory.

Import declarations

An import declaration states that the source file containing the declaration uses identifiers
exported by the imported package and enables access to them. The import names an identifier
(PackageName) to be used for access and an ImportPath that specifies the package to be imported.

ImportDecl       = "import" ( ImportSpec | "(" { ImportSpec ";" } ")" ) .
ImportSpec       = [ "." | PackageName ] ImportPath .
ImportPath       = string_lit .

The PackageName is used in qualified identifiers to access the exported identifiers of the package
within the importing source file. It is declared in the file block. If the PackageName is omitted,
it defaults to the identifier specified in the package clause of the imported package. If an
explicit period (.) appears instead of a name, all the package's exported identifiers will be
declared in the current file's file block and can be accessed without a qualifier.

The interpretation of the ImportPath is implementation-dependent but it is typically a substring of
the full file name of the compiled package and may be relative to a repository of installed
packages.

Assume we have compiled a package containing the package clause package math, which exports
function Sin, and installed the compiled package in the file identified by "lib/math". This table
illustrates how Sin may be accessed in files that import the package after the various types of
import declaration.

Import declaration          Local name of Sin

import   "lib/math"         math.Sin
import M "lib/math"         M.Sin
import . "lib/math"         Sin

An import declaration declares a dependency relation between the importing and imported package. It
is illegal for a package to import itself or to import a package without referring to any of its
exported identifiers. To import a package solely for its side-effects (initialization), use the
blank identifier as explicit package name:

import _ "lib/math"

An example package

Here is a complete Go package that implements a concurrent prime sieve.

package main

import "fmt"

// Send the sequence 2, 3, 4, ... to channel 'ch'.
func generate(ch chan<- int) {
    for i := 2; ; i++ {
        ch <- i  // Send 'i' to channel 'ch'.
    }
}

// Copy the values from channel 'src' to channel 'dst',
// removing those divisible by 'prime'.
func filter(src <-chan int, dst chan<- int, prime int) {
    for i := range src {    // Loop over values received from 'src'.
        if i%prime != 0 {
            dst <- i  // Send 'i' to channel 'dst'.
        }
    }
}

// The prime sieve: Daisy-chain filter processes together.
func sieve() {
    ch := make(chan int)  // Create a new channel.
    go generate(ch)       // Start generate() as a subprocess.
    for {
        prime := <-ch
        fmt.Print(prime, "\n")
        ch1 := make(chan int)
        go filter(ch, ch1, prime)
        ch = ch1
    }
}

func main() {
    sieve()
}

Program initialization and execution

The zero value

When memory is allocated to store a value, either through a declaration or a call of make or new,
and no explicit initialization is provided, the memory is given a default initialization. Each
element of such a value is set to the zero value for its type: false for booleans, 0 for integers,
0.0 for floats, "" for strings, and nil for pointers, functions, interfaces, slices, channels, and
maps. This initialization is done recursively, so for instance each element of an array of structs
will have its fields zeroed if no value is specified.

These two simple declarations are equivalent:

var i int
var i int = 0

After

type T struct { i int; f float64; next *T }
t := new(T)

the following holds:

t.i == 0
t.f == 0.0
t.next == nil

The same would also be true after

var t T

Program execution

A package with no imports is initialized by assigning initial values to all its package-level
variables and then calling any package-level function with the name and signature of

func init()

defined in its source. A package may contain multiple init functions, even within a single source
file; they execute in unspecified order.

Within a package, package-level variables are initialized, and constant values are determined, in
data-dependent order: if the initializer of A depends on the value of B, A will be set after B. It
is an error if such dependencies form a cycle. Dependency analysis is done lexically: A depends on
B if the value of A contains a mention of B, contains a value whose initializer mentions B, or
mentions a function that mentions B, recursively. If two items are not interdependent, they will be
initialized in the order they appear in the source. Since the dependency analysis is done per
package, it can produce unspecified results if A's initializer calls a function defined in another
package that refers to B.

Initialization code may contain "go" statements, but the functions they invoke do not begin
execution until initialization of the entire program is complete. Therefore, all initialization
code is run in a single goroutine.

An init function cannot be referred to from anywhere in a program. In particular, init cannot be
called explicitly, nor can a pointer to init be assigned to a function variable.

If a package has imports, the imported packages are initialized before initializing the package
itself. If multiple packages import a package P, P will be initialized only once.

The importing of packages, by construction, guarantees that there can be no cyclic dependencies in
initialization.

A complete program is created by linking a single, unimported package called the main package with
all the packages it imports, transitively. The main package must have package name main and declare
a function main that takes no arguments and returns no value.

func main() { ... }

Program execution begins by initializing the main package and then invoking the function main.

When the function main returns, the program exits. It does not wait for other (non-main) goroutines
to complete.

Run-time panics

Execution errors such as attempting to index an array out of bounds trigger a run-time panic
equivalent to a call of the built-in function panic with a value of the implementation-defined
interface type runtime.Error. That type defines at least the method String() string. The exact
error values that represent distinct run-time error conditions are unspecified, at least for now.

package runtime

type Error interface {
    String() string
    // and perhaps others
}

System considerations

Package unsafe

The built-in package unsafe, known to the compiler, provides facilities for low-level programming
including operations that violate the type system. A package using unsafe must be vetted manually
for type safety. The package provides the following interface:

package unsafe

type ArbitraryType int  // shorthand for an arbitrary Go type; it is not a real type
type Pointer *ArbitraryType

func Alignof(variable ArbitraryType) uintptr
func Offsetof(selector ArbitraryType) uinptr
func Sizeof(variable ArbitraryType) uintptr

func Reflect(val interface{}) (typ runtime.Type, addr uintptr)
func Typeof(val interface{}) (typ interface{})
func Unreflect(typ runtime.Type, addr uintptr) interface{}

Any pointer or value of type uintptr can be converted into a Pointer and vice versa.

The function Sizeof takes an expression denoting a variable of any type and returns the size of the
variable in bytes.

The function Offsetof takes a selector (§Selectors) denoting a struct field of any type and returns
the field offset in bytes relative to the struct's address. For a struct s with field f:

uintptr(unsafe.Pointer(&s)) + unsafe.Offsetof(s.f) == uintptr(unsafe.Pointer(&s.f))

Computer architectures may require memory addresses to be aligned; that is, for addresses of a
variable to be a multiple of a factor, the variable's type's alignment. The function Alignof takes
an expression denoting a variable of any type and returns the alignment of the (type of the)
variable in bytes. For a variable x:

uintptr(unsafe.Pointer(&x)) % unsafe.Alignof(x) == 0

Calls to Alignof, Offsetof, and Sizeof are compile-time constant expressions of type uintptr.

The functions unsafe.Typeof, unsafe.Reflect, and unsafe.Unreflect allow access at run time to the
dynamic types and values stored in interfaces. Typeof returns a representation of val's dynamic
type as a runtime.Type. Reflect allocates a copy of val's dynamic value and returns both the type
and the address of the copy. Unreflect inverts Reflect, creating an interface value from a type and
address. The reflect package built on these primitives provides a safe, more convenient way to
inspect interface values.

Size and alignment guarantees

For the numeric types (§Numeric types), the following sizes are guaranteed:

type                                 size in bytes

byte, uint8, int8                     1
uint16, int16                         2
uint32, int32, float32                4
uint64, int64, float64, complex64     8
complex128                           16

The following minimal alignment properties are guaranteed:

 1. For a variable x of any type: unsafe.Alignof(x) is at least 1.
 2. For a variable x of struct type: unsafe.Alignof(x) is the largest of all the values
    unsafe.Alignof(x.f) for each field f of x, but at least 1.
 3. For a variable x of array type: unsafe.Alignof(x) is the same as unsafe.Alignof(x[0]), but at
    least 1.

Implementation differences - TODO

  * len(a) is only a constant if a is a (qualified) identifier denoting an array or pointer to an
    array.
  * nil maps are not treated like empty maps.
  * Trying to send/receive from a nil channel causes a run-time panic.
  * unsafe.Alignof, unsafe.Offsetof, and unsafe.Sizeof return an int.

release.r60.3. Except as noted, this content is licensed under a Creative Commons Attribution 3.0
License.
#+end_example
*** [#A] web page: Early syntax errors and other minor errors
    http://golangtutorials.blogspot.com/2011/05/early-syntax-errors-and-other-minor.html
**** webcontent                                                    :noexport:
   #+begin_example
Sometimes we know what works right, but we don't know what works wrong. Let me make a list of a few errors that one could encounter so that you don't waste much time figuring it out.

Unncessary Imports
Copy the code below into a file and execute it.

Full file: ErrProg1.go

package main

import "fmt"
import "os" //excessive - we are not using any function in this package

func main() {
 fmt.Println("Hello world")
}


Output:
prog.go:4: imported and not used: os

Go is particularly parsimonious when it comes to code - if you are not going to use something, don't ask for it. Here, you have indicated that you want to import the os package but you haven't used it anywhere. That's not allowed. If you are not using it, remove it. If you remove the import os at line 4, this program will work.

Exact Names - case dependent

Full file: ErrProg2.go

package main

import "fmt"

func main() {
 fmt.println("Hello world")
}


Output:
prog.go:6: cannot refer to unexported name fmt.println
prog.go:6: undefined: fmt.println

Notice how we have written fmt.println and not fmt.Println. Go is case dependent, which means to say that when you use another's name, use it exactly as it is defined. If the name is John, then only John works - not john, not joHn, and no other combination. So, in this case some of the others that are not allowed:

Invalid code

Package main
iMport "fmt"
import "Fmt"
Func main() {}
Fmt.Println
fmt.println


Separating lines with semicolons
If you are coming from a background in languages like C, C++, Java, Perl, etc. you will notice that Go (at least so far) has not required you to put semi colons at the end of the line. In Go, the new line character automatically indicates the end of the line. However, if you happen to put two statements in the same line, then you need to have a semicolon separating them. Let's take a look at an example.

Full file: ErrProg3.go

package main

import "fmt"

func main() {
 fmt.Println("Hello world") fmt.Println("Hi again")
}


Output:
prog.go:6: syntax error: unexpected name, expecting semicolon or newline or }

Now you could make this work by putting the two Println statements on two separate lines, like so:

Partial file

func main() {
 fmt.Println("Hello world")
            fmt.Println("Hi again")
}


But for the purpose of illustrating this example, try out this version.

Full file:

package main

import "fmt"

func main() {
 fmt.Println("Hello world"); fmt.Println("Hi again")
}


Output:
Hello world
Hi again

So, semi colons in Go can be used but are not compulsory on every line. But if you are going to have multiple statements in a line, you need to separate them with semi colons.

So this one is also valid and will get you the same output.
Full file: ErrProg4.go

package main;

import "fmt";

func main() {
 fmt.Println("Hello world"); fmt.Println("Hi again");
};


Output:
Hello world
Hi again

But watch out where you go with all those free semicolons.

Unnecessary semicolons

Let's simplify that program, but go overboard with our semicolons. Try out this code now.

Full file

package main

import "fmt";;

func main() {
 fmt.Println("Hello world")
}


Output:
prog.go:3: empty top-level declaration

Again, Go is strictly frugal with its code. Here, alongside the import statement, there are two semicolons. Now the first one is acceptable - not necessary here, but acceptable. But two! Nope, that is where Go draws the line. The semicolon indicates the end of a statement, but there is no valid statement prior to the second semicolon. So remove the extra semicolon and all should be fine again.

Syntax and other things
The compiler demands that you follow proper syntax. There are a large possibility of syntax errors and it wouldn't be a good idea to list them all. But I shall list a few. If you know these ones, most of the rest are just similar.

package 'main' //ERROR - no quotes for the package name: package main
package "main" //ERROR - no quotes for the package: package main

package main.x  //ERROR - packages names in go are just one expression.  So either package main or package x.
package main/x  //ERROR - packages names in go are just one expression.  So either package main or package x.

import 'fmt' //ERROR - needs double quotes "fmt"
import fmt //ERROR - needs double quotes "fmt"

func main { } //ERROR - functions have to be followed by parantheses: func main() {}

func main() [] //ERROR - where curly braces are required, only those are allowed.  They are used to contain blocks of code.  func main() {}

func main() { fmt.Println('hello world') } //ERROR - use double quotes for strings: func main() { fmt.Println("hello world") }
   #+end_example
* #  --8<-------------------------- separator ------------------------>8-- :noexport:
* TODO golang lint                                                 :noexport:
https://github.com/securego/gosec
https://github.com/golangci/golangci-lint
* TODO consolidate and think beyond: https://github.com/a8m/go-lang-cheat-sheet :noexport:
* TODO golang rune, byte                                           :noexport:
* HALF golang set: doesn't have                                    :noexport:
https://github.com/deckarep/golang-set

Coming from Python one of the things I miss is the superbly wonderful set collection.

This is my attempt to mimic the primary features of the set from Python. You can of course argue that there is no need for a set in Go, otherwise the creators would have added one to the standard library. To those I say simply ignore this repository and carry-on and to the rest that find this useful please contribute in helping me make it better by
* TODO golang byte, rune, string: https://leetcode.com/problems/shortest-distance-to-a-character/discuss/125941/Golang-BFS :noexport:
* HALF doc: release ram usage earlier, thus we can lower the space complexity: https://leetcode.com/problems/number-of-boomerangs/description/ :noexport:
* TODO ginkgo unfocus; ginkgo -r; ginkgo -r -v                     :noexport:
* TODO golang Focus, Pend                                          :noexport:
* TODO golang timeout                                              :noexport:
* TODO golang net.Listener accept timeout                          :noexport:
https://stackoverflow.com/questions/37386303/setting-timeout-via-setdeadline-for-tcp-listener
* TODO [#A] golang zero or more syntax                             :noexport:
* TODO golang json add tags                                        :noexport:
* TODO golang compare byte                                         :noexport:
* TODO golang stack                                                :noexport:
https://stackoverflow.com/questions/28541609/looking-for-reasonable-stack-implementation-in-golang
* #  --8<-------------------------- separator ------------------------>8-- :noexport:
* HALF golang check type of variable                               :noexport:
* TODO golang loop character in string: string to a slice of unicode code: range []rune(input) :noexport:
* TODO consolidate: https://jimmysong.io/cheatsheets/go            :noexport:
* HALF avoid global variable: https://code.dennyzhang.com/boundary-of-binary-tree :noexport:
* #  --8<-------------------------- separator ------------------------>8-- :noexport:
* TODO golang implement a queue                                    :noexport:
* HALF golang byte, rune, string                                   :noexport:
#+BEGIN_SRC go
// Blog link: https://brain.dennyzhang.com/roman-to-integer
// Basic Ideas: Examine from left to right.
//     If current is smaller than the next, substract. Otherwise, add
//
// Complexity: Time O(n), Space O(1)
// Related reading: https://en.wikipedia.org/wiki/Roman_numerals#Roman_numeric_system
func romanToInt(s string) int {
    m := map[byte]int{'I': 1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}
    res := 0
    for i, _ := range s {
        if i == len(s)-1 {
            res += m[s[i]]
        } else{
            if m[s[i]] < m[s[i+1]] {
                res -= m[s[i]]
            } else {
                res += m[s[i]]
            }
        }
    }
    return res
}
#+END_SRC

* TODO golang bytes.buffer: https://code.dennyzhang.com/integer-to-roman :noexport:
* TODO golang zip: https://golang.org/pkg/archive/zip/             :noexport:
* TODO golang array with tuple                                     :noexport:
https://stackoverflow.com/questions/13670818/pair-tuple-data-type-in-go

type Pair struct {
    a, b interface{}
}

* TODO golang concat two slices                                    :noexport:
* TODO golang insert into slice by index                           :noexport:
* TODO golang: string and type                                     :noexport:
https://leetcode.com/contest/weekly-contest-82/problems/goat-latin/
// Basic Ideas: Split string as a list first
// Complexity: Time O(n), Space O(n)
import "strings"
func toGoatLatin(S string) string {
    res := ""
    for i, word := range strings.Split(S, " ") {
        ch := strings.ToLower(string(word[0]))
        item := ""
        if strings.Index("aeiouAEIOU", ch) != -1 {
            item = word+"ma"
        } else {
            item = word[1:]+word[0]+"ma"
        }
        item = item + strings.Repeat("a", i+1)
        res += item + " "
    }
    return res[0:len(res)-1]
}
* TODO [#A] github: golang chanllenges                             :noexport:
https://github.com/golang-collections/collections
** implement trie in golang
https://code.dennyzhang.com/short-encoding-of-words
https://github.com/derekparker/trie/blob/master/trie.go
** implement bfs in golang: make sure the time complexity is consistent?
** manage your code as a package
https://github.com/cespare/go-trie/blob/master/trie.go
package trie
* #  --8<-------------------------- separator ------------------------>8-- :noexport:
* TODO local notes                                                 :noexport:
** TODO golang initialize array with -1                             :noexport:
    l := [26]int{}
    for i, _ := range l{ l[i]=-1 }
** TODO golang add assertion: https://godoc.org/github.com/stretchr/testify/assert :noexport:
** TODO golang check whether element exists in slices               :noexport:
https://stackoverflow.com/questions/10485743/contains-method-for-a-slice
** HALF golang create a set for (i, j)                              :noexport:
** HALF golang hashmap can't use struct as key
https://play.golang.org/p/FcY_0ckwOZ

** TODO golang []rune to string
** TODO golang abs
https://github.com/golang/go/issues/15447
func abs(v int) int {
    if v<0 { return -v }
    return v
}

** TODO golang string to array
** TODO golang compare two float numbers
** TODO golang add item to the head
s = append([]int{0}, s...)
** TODO golang initialize a list with a different default value
    l := make([]int, len(nums))
    for i:= 0; i<len(nums); i++ { l[i] = 1 }
** TODO mac install golang
https://golang.org/doc/install
** TODO golang interface to struct
** TODO golang testing
import "testing"

function TestSomething(t *testing.T) {
   if true {
      t.Error("test failure message")
   }

   if true {
      t.Errorf("test %s message", "failure")
   }
}
** TODO golang exec
#+BEGIN_EXAMPLE
Eventually(session).Should(gexec.Exit(0))
//the wrapped command should exit with status 0, eventually

Eventually(buffer).Should(Say("something matching this regexp"))
Eventually(session.Out).Should(Say("Splines reticulated"))
#+END_EXAMPLE
** TODO golang namespace convention
Use MixedCase
Names in Go should use MixedCase.

(Don't use names_with_underscores.)

Acronyms should be all capitals, as in ServeHTTP and IDProcessor.
** TODO git sub-module: /Users/zdenny/Dropbox/private_data/work/vmware/k8s-observability/code/github
** TODO golang bufio
** TODO golang import private repo
** TODO go depths
** TODO golang interface: spec := o.(*v1beta1.Drain).Spec
** TODO golang no switch
** TODO golang json marshal, json unmarshal
** TODO emacs golang auto complete
** TODO emacs golang go to the function definition
** TODO golang import
import (
	"bufio"
	"flag"
	"fmt"
	"os"
	"path/filepath"

	appsv1 "k8s.io/api/apps/v1"
	apiv1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/util/homedir"
	"k8s.io/client-go/util/retry"
	// Uncomment the following line to load the gcp plugin (only required to authenticate against GKE clusters).
	// _ "k8s.io/client-go/plugin/pkg/client/auth/gcp"
)
** TODO go run cmd/main.go --kubeconfig=$HOME/.kube/config
** TODO golang logging with metrics
** TODO golang vgo for task dependency
** TODO golang os/exec
** TODO golang github.com/onsi/gomega/gexec: gexec.CleanupBuildArtifacts()
** TODO go get -t -d "github.com/onsi/gomega" ...  | go get -t -d "github.com/onsi/gomega"
** TODO golang process issue: /Users/zdenny/Dropbox/private_data/work/vmware/denny_code/fluent-bit-out-syslog.problem
#+BEGIN_EXAMPLE
bash-3.2$ go test -v
=== RUN   TestCmd
Running Suite: Cmd Suite
========================
Random Seed: 1530651210
Will run 3 of 3 specs

absWd: /Users/zdenny/Dropbox/private_data/work/vmware/denny_code/fluent-bit-out-syslog/cmd  path: /usr/local/Cellar/go/packages  absPath: /usr/local/Cellar/go/packages
/usr/local/bin//docker
Failure [0.015 seconds]
[BeforeSuite] BeforeSuite
/Users/zdenny/Dropbox/private_data/work/vmware/denny_code/fluent-bit-out-syslog/cmd/cmd_suite_test.go:30

  Expected error:
      <*errors.errorString | 0xc42028a040>: {
          s: "unable to find go path dir",
      }
      unable to find go path dir
  not to have occurred

  /Users/zdenny/Dropbox/private_data/work/vmware/denny_code/fluent-bit-out-syslog/cmd/cmd_suite_test.go:55
------------------------------

Ran 3 of 0 Specs in 0.015 seconds
FAIL! -- 0 Passed | 3 Failed | 0 Pending | 0 Skipped
--- FAIL: TestCmd (0.02s)
FAIL
exit status 1
FAIL	_/Users/zdenny/Dropbox/private_data/work/vmware/denny_code/fluent-bit-out-syslog/cmd	0.067s
bash-3.2$
#+END_EXAMPLE

#+BEGIN_EXAMPLE
package main_test

import (
	"errors"
	"io/ioutil"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"strings"
	"testing"
	"time"
	"fmt"

	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
	"github.com/onsi/gomega/gexec"
)

func TestCmd(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Cmd Suite")
}

var (
	pluginPath string
	cleanup    = func() {}
)

var _ = BeforeSuite(func() {
	detectDocker()
	pluginPath, cleanup = buildPlugin()
})

var _ = AfterSuite(func() {
	cleanup()
})

func detectDocker() {
	cmd := exec.Command("which", "docker")
	sess, err := gexec.Start(cmd, GinkgoWriter, GinkgoWriter)
	Expect(err).ToNot(HaveOccurred())
	sess.Wait()
	if sess.ExitCode() != 0 {
		Fail("docker is required to be installed and running on your machine" +
			" in order to build the plugin and run it with fluent bit")
	}
}

func buildPlugin() (string, func()) {
	tmpPath, err := ioutil.TempDir("/tmp", "")
	Expect(err).ToNot(HaveOccurred())

	gopath, err := goPath()
	Expect(err).ToNot(HaveOccurred())
	cmd := exec.Command(
		"docker",
		"run",
		"--volume", gopath+":/go",
		"--volume", tmpPath+":/output",
		"golang:latest",
		"go",
		"build",
		"-buildmode", "c-shared",
		"-o", "/output/out_syslog.so",
		"github.com/oratos/out_syslog/cmd",
	)
	sess, err := gexec.Start(cmd, GinkgoWriter, GinkgoWriter)
	Expect(err).ToNot(HaveOccurred())
	sess.Wait(5 * time.Minute)

	return path.Join(tmpPath, "out_syslog.so"), func() {
		err := os.RemoveAll(tmpPath)
		Expect(err).ToNot(HaveOccurred())
	}
}

func goPath() (string, error) {
	wd, err := os.Getwd()
	if err != nil {
		return "", err
	}
	absWd, err := filepath.Abs(wd)
	if err != nil {
		return "", err
	}
	for _, path := range strings.Split(os.Getenv("GOPATH"), ":") {
		absPath, err := filepath.Abs(path)
		fmt.Println("absWd:", absWd, " path:", path, " absPath:", absPath)
		if err != nil {
			continue
		}
		if strings.Contains(absWd, absPath) {
			return absPath, nil
		}
	}
	return "", errors.New("unable to find go path dir")
}

#+END_EXAMPLE

** TODO golang use switch: https://code.dennyzhang.com/utf-8-validation
** TODO golang use pointer as hashmap key
** HALF golang get map keys
https://stackoverflow.com/questions/41690156/how-to-get-the-keys-as-string-array-from-map-in-go-lang/41691320
** TODO golang whether needs to delete pointer?
https://leetcode.com/problems/design-linked-list/description/

** TODO golang glog
"github.com/golang/glog"

** TODO [#A] https://golang.org/doc/code.html#Workspaces
** TODO [#A] https://golang.org/doc/effective_go.html
** TODO golang HTTP.GET()
** TODO golang []unit8, []byte
** TODO golang coverage: go tool cover
go test -cover
** HALF golang $GOROOT and $GOPATH
https://astaxie.gitbooks.io/build-web-application-with-golang/en/01.2.html

export GOROOT=/usr/local/Cellar/go/1.10.3/libexec
export GOPATH=/usr/local/Cellar/go/packages

#+BEGIN_EXAMPLE
export GOPATH="/Users/***/work/go"
export GO="/usr/local/Cellar/go/1.8.3"
export GOROOT=$GO/libexec
export PATH=$GO/bin:$GOPATH/bin:$PATH
#+END_EXAMPLE

** TODO golang rune vs byte
** TODO golang check whether item in a int slice
** TODO golang: https://github.com/SimonWaldherr/golang-examples
** TODO golang: https://github.com/golang/example
** TODO emacs golang: https://johnsogg.github.io/emacs-golang
http://tleyden.github.io/blog/2014/05/22/configure-emacs-as-a-go-editor-from-scratch/

** HALF golang copy a map: you need to copy them by yourself
package main

import (
"fmt"
)
func main() {
    map1 := map[string]int{
        "x":1,
        "y":2,
    }
    map2 := map[string]int{}

    /* Copy Content from Map1 to Map2*/
    for index,element := range map1{
         map2[index] = element
    }

    for index,element := range map2{
        fmt.Println(index,"=>",element)
    }
}
http://www.golangprograms.com/how-to-copy-a-map-to-another.html

https://stackoverflow.com/questions/23057785/how-to-copy-a-map
** TODO golang struct: by pointer or by reference
** TODO golang import and golang import .
#+BEGIN_EXAMPLE
import (
	"testing"

	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
)
#+END_EXAMPLE

** TODO [#A] emacs setup for golang
https://godoc.org/golang.org/x/tools/cmd/goimports
godoc.org
Command goimports
Command goimports updates your Go import lines, adding missing ones and removing unreferenced ones.
This tool is a superset of gofmt that also fixes import statements.

** TODO golang strings.EqualFold
https://github.com/pivotal-cf/fluent-bit-out-syslog/pull/11/files
** HALF golang add assertion
** HALF golang create tmp folders/files
#+BEGIN_SRC go

+func openWriteFile() (*os.File, func()) {
+	tmpDir, err := ioutil.TempDir("/tmp", "")
+	Expect(err).ToNot(HaveOccurred())
+
+	f, err := ioutil.TempFile(tmpDir, "")
+	Expect(err).ToNot(HaveOccurred())
+
+	return f, func() {
+		err := os.RemoveAll(tmpDir)
+		Expect(err).ToNot(HaveOccurred())
+	}
+}
#+END_SRC

** TODO effective go: https://golang.org/doc/effective_go.html
https://talks.golang.org/2010/ExpressivenessOfGo-2010.pdf
** TODO golang workspace: https://golang.org/doc/code.html#Workspaces
** TODO why golang name it slice, instead of list or array?
** TODO understand golang interfaces
Interfaces are one of most important building blocks of golang. Also, its usage make golang as language very simpler to use. for example, you can look into "io" package.
http://kunalkushwaha.github.io/2015/09/11/understanding-golang-interfaces/
** TODO emacs flymake for golang: when we save file, run code static check
** TODO golang ...
	ts.start(handlerOptions...)
	return ts
}

func (t *tcpServer) start(handlerOptions ...HandlerOptions) {
	log.Printf("Starting syslog server on: %s", t.syslogAddr)
	var err error
** TODO go mod
** TODO go test --gingo -v
** HALF types.go
** TODO go bin
bin.go

MustAsset
doc.go

go generate
** TODO operator: go code generator
** TODO go path issue
 out.go    10   2 error           cannot find package "code.cloudfoundry.org/rfc5424" in any of:
 	/usr/local/Cellar/go/1.10.3/libexec/src/code.cloudfoundry.org/rfc5424 (from $GOROOT)
 	/Users/zdenny/go/src/code.cloudfoundry.org/rfc5424 (from $GOPATH) (go-build)
** TODO go test -race: https://github.com/pivotal-cf/oratos-ci/commit/7d47cc4820e9dce8ba7ba55c5a888cd6f7f5ab92
go test $(eval "$PKGS_HOOK") -race
** TODO go test $(go list ./... | grep -v vendor) -race
** TODO go spew
** TODO go module
cd cmd

go build

~/go/pkg/mod
** TODO go test ./... -race
** TODO Go Buildpack
** TODO go get, go mod
https://github.com/golang/go/wiki/Modules
** TODO go over the nsx-t process manually: https://www.youtube.com/watch?v=B7XOoOCiM00&list=PL7bmigfV0EqQzsvOcT8KYfulg-lpNsooC&index=2
** TODO go swagger
* TODO [#A] Ginkgo choose test scenario conditionally: env_type    :noexport:
https://www.agiratech.com/golang-testing-using-ginkgo/
* TODO ginkgo BeforeEach check context name                        :noexport:
* #  --8<-------------------------- separator ------------------------>8-- :noexport:
* TODO golang channel: https://bitbucket.org/devops_sysops/cheatsheetcollection/src/a4b5d9acc0a852254a2eb8719068f9361d99e426/Go%20Examples/GoChannels.md?fileviewer=file-view-default :noexport:
* TODO consolidate https://github.com/JeffDeCola/my-cheat-sheets/tree/master/software/development/languages/go-cheat-sheet :noexport:
* TODO golang mod code                                             :noexport:
#+BEGIN_SRC golang
	if -3 % 2 == 1 {
		fmt.Println("Yes")
	} else {
		fmt.Println("No")
	}
#+END_SRC
* go-dep                                                           :noexport:
https://github.com/golang/dep

 curl https://raw.githubusercontent.com/golang/dep/master/install.sh | sh
 apt-get install -y go-dep
* TODO golang rune vs byte                                         :noexport:
* TODO golang heap                                                 :noexport:
https://golang.org/pkg/container/heap/#example__priorityQueue
* HALF golang deepcopy an array                                    :noexport:
* #  --8<-------------------------- separator ------------------------>8-- :noexport:
* TODO [#A] one of Go's distinguishing features is the goroutine   :noexport:
https://sdtimes.com/softwaredev/the-developers-dilemma-choosing-between-go-and-rust/
* golang profiling: http://brendanjryan.com/golang/profiling/2018/02/28/profiling-go-applications.html :noexport:
* #  --8<-------------------------- separator ------------------------>8-- :noexport:
* TODO Read: https://golang.org/doc/effective_go.html              :noexport:
* [#A] golang BDD test: ginkgo gomega                    :noexport:IMPORTANT:
Check
| Name              | Summary                                                              |
|-------------------+----------------------------------------------------------------------|
| Equal             | primitives comparision                                               |
| reflect.DeepEqual | recursively dig into maps, slices, arrays, and even your own structs |
| BeEquivalentTo    | compare across different types                                       |
| ContainSubstring  |                                                                      |
| HavePrefix        |                                                                      |
| Equal             |                                                                      |
| BeTrue            |                                                                      |
| BeNil             |                                                                      |
** TODO Making Assertions in Helper Functions
http://onsi.github.io/gomega/#making-assertions-in-helper-functions

#+BEGIN_SRC go
var _ = Describe("Turbo-encabulator", func() {
    ...
    func assertTurboEncabulatorContains(components ...string) {
        teComponents, err := turboEncabulator.GetComponents()
        Expect(err).NotTo(HaveOccurred())

        Expect(teComponents).To(HaveLen(components))
        for _, component := range components {
            Expect(teComponents).To(ContainElement(component))
        }
    }

    It("should have components", func() {
        assertTurboEncabulatorContains("semi-boloid slots", "grammeters")
    })
})
#+END_SRC
** TODO NotTo vs ToNot
http://onsi.github.io/gomega/
#+BEGIN_EXAMPLE
  Expect(ACTUAL).To(Equal(EXPECTED))
  Expect(ACTUAL).NotTo(Equal(EXPECTED))
  Expect(ACTUAL).ToNot(Equal(EXPECTED))
#+END_EXAMPLE
** #  --8<-------------------------- separator ------------------------>8-- :noexport:
** DONE GomegaAssertion interface: Should, ShouldNot, To, ToNot, NotTo
   CLOSED: [2018-07-04 Wed 21:52]
http://onsi.github.io/gomega/
#+BEGIN_EXAMPLE
  Expect(ACTUAL).To(Equal(EXPECTED))
  Expect(ACTUAL).NotTo(Equal(EXPECTED))
  Expect(ACTUAL).ToNot(Equal(EXPECTED))
#+END_EXAMPLE

http://onsi.github.io/gomega/

https://godoc.org/github.com/onsi/gomega

Expect(err).To(HaveOccurred())
Expect("foo").To(Equal("foo"))
** DONE example: gexec-example
   CLOSED: [2018-07-04 Wed 21:52]
https://github.com/Amit-PivotalLabs/gexec-example
** DONE Add msg to assertions: Ω(SprocketsAreLeaky()).Should(BeFalse(), "Sprockets shouldn't leak")
   CLOSED: [2018-07-04 Wed 21:52]
** DONE [#A] Asynchronous Assertions: Eventually, Consistently
   CLOSED: [2018-07-04 Wed 22:37]
http://onsi.github.io/gomega/#making-asynchronous-assertions

- Eventually will poll the passed in function (which must have zero-arguments and at least one return value) repeatedly and check the return value against the GomegaMatcher
  Eventually then blocks until the match succeeds or until a timeout interval has elapsed.

- Consistently checks that an assertion passes for a period of time. It does this by polling its argument repeatedly during the period. It fails if the matcher ever fails during that period.

#+BEGIN_EXAMPLE
Eventually(func() []int {
    return thing.SliceImMonitoring
}).Should(HaveLen(2))

Eventually(func() string {
    return thing.Status
}).ShouldNot(Equal("Stuck Waiting"))
#+END_EXAMPLE

#+BEGIN_EXAMPLE
Consistently(func() []int {
    return thing.MemoryUsage()
}).Should(BeNumerically("<", 10))
#+END_EXAMPLE
#+BEGIN_SRC go
	Context("when exitCode flag is passed explicitly", func() {
		BeforeEach(func() {
			command = exec.Command(pathToExecutable, "-exitCode=33")
		})

		It("exits with the passed in value", func() {
			session, err := gexec.Start(command, GinkgoWriter, GinkgoWriter)
			Ω(err).ShouldNot(HaveOccurred())

			Eventually(session).Should(gexec.Exit(33))
		})
	})
#+END_SRC
** #  --8<-------------------------- separator ------------------------>8-- :noexport:
** ginkgo structure
https://github.com/onsi/ginkgo

Structure your BDD-style tests expressively:

Nestable Describe, Context and When container blocks
BeforeEach and AfterEach blocks for setup and teardown
It and Specify blocks that hold your assertions
JustBeforeEach blocks that separate creation from configuration (also known as the subject action pattern).
BeforeSuite and AfterSuite blocks to prep for and cleanup after a suite.
** Concept: defer
** Concept: context
** #  --8<-------------------------- separator ------------------------>8-- :noexport:
** TODO DescribeTable
** TODO gexec.Build("github.com/amitkgupta/gexec-example"): https://github.com/Amit-PivotalLabs/gexec-example/blob/master/gexec_example_test.go#L17
How I distribute my test code
* golang questions                                                 :noexport:
** TODO golang hashmap: map[[4]int] vs map[[]int]
** TODO golang garbage collection
** TODO go get -u k8s.io/client-go/..., vs  go get -u k8s.io/client-go vs go get -d -v k8s.io/client-go
https://github.com/ponzu-cms/ponzu/issues/204
* TODO golang hashmap use struct as key                            :noexport:
Need to be hashable
* #  --8<-------------------------- separator ------------------------>8-- :noexport:
* TODO Q: Is golang runtime like JVM?                              :noexport:
